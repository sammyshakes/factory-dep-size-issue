{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/PackedCounter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n// - Last 7 bytes (uint56) are used for the total byte length of the dynamic data\n// - The next 5 byte (uint40) sections are used for the byte length of each field, indexed from right to left\ntype PackedCounter is bytes32;\n\nusing PackedCounterInstance for PackedCounter global;\n\n// Number of bits for the 7-byte accumulator\nuint256 constant ACC_BITS = 7 * 8;\n// Number of bits for the 5-byte sections\nuint256 constant VAL_BITS = 5 * 8;\n// Maximum value of a 5-byte section\nuint256 constant MAX_VAL = type(uint40).max;\n\n/**\n * Static functions for PackedCounter\n * The caller must ensure that the value arguments are <= MAX_VAL\n */\nlibrary PackedCounterLib {\n  function pack(uint256 a) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d + e;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n      packedCounter |= (uint256(e) << (ACC_BITS + VAL_BITS * 4));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n}\n\n/**\n * Instance functions for PackedCounter\n */\nlibrary PackedCounterInstance {\n  error PackedCounter_InvalidLength(uint256 length);\n\n  /**\n   * Decode the accumulated counter\n   * (right-most 7 bytes of packed counter)\n   */\n  function total(PackedCounter packedCounter) internal pure returns (uint256) {\n    return uint56(uint256(PackedCounter.unwrap(packedCounter)));\n  }\n\n  /**\n   * Decode the counter at the given index\n   * (right-to-left, 5 bytes per counter after the right-most 7 bytes)\n   */\n  function atIndex(PackedCounter packedCounter, uint8 index) internal pure returns (uint256) {\n    unchecked {\n      return uint40(uint256(PackedCounter.unwrap(packedCounter) >> (ACC_BITS + VAL_BITS * index)));\n    }\n  }\n\n  /**\n   * Set a counter at the given index, return the new packed counter\n   */\n  function setAtIndex(\n    PackedCounter packedCounter,\n    uint8 index,\n    uint256 newValueAtIndex\n  ) internal pure returns (PackedCounter) {\n    if (newValueAtIndex > MAX_VAL) {\n      revert PackedCounter_InvalidLength(newValueAtIndex);\n    }\n\n    uint256 rawPackedCounter = uint256(PackedCounter.unwrap(packedCounter));\n\n    // Get current lengths (total and at index)\n    uint256 accumulator = total(packedCounter);\n    uint256 currentValueAtIndex = atIndex(packedCounter, index);\n\n    // Compute the difference and update the total value\n    unchecked {\n      if (newValueAtIndex >= currentValueAtIndex) {\n        accumulator += newValueAtIndex - currentValueAtIndex;\n      } else {\n        accumulator -= currentValueAtIndex - newValueAtIndex;\n      }\n    }\n\n    // Set the new accumulated value and value at index\n    // (7 bytes total length, 5 bytes per dynamic field)\n    uint256 offset;\n    unchecked {\n      offset = ACC_BITS + VAL_BITS * index;\n    }\n    // Bitmask with 1s at the 5 bytes that form the value slot at the given index\n    uint256 mask = uint256(type(uint40).max) << offset;\n\n    // First set the last 7 bytes to 0, then set them to the new length\n    rawPackedCounter = (rawPackedCounter & ~uint256(type(uint56).max)) | accumulator;\n\n    // Zero out the value slot at the given index, then set the new value\n    rawPackedCounter = (rawPackedCounter & ~mask) | ((newValueAtIndex << offset) & mask);\n\n    return PackedCounter.wrap(bytes32(rawPackedCounter));\n  }\n\n  /*\n   * Unwrap the packed counter\n   */\n  function unwrap(PackedCounter packedCounter) internal pure returns (bytes32) {\n    return PackedCounter.unwrap(packedCounter);\n  }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}