{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/FieldLayout.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { WORD_SIZE, WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants_1.sol\";\n\n// - 2 bytes for total length of all static fields\n// - 1 byte for number of static size fields\n// - 1 byte for number of dynamic size fields\n// - 28 bytes for 28 static field lengths\n// (MAX_DYNAMIC_FIELDS allows PackedCounter to pack the dynamic lengths into 1 word)\ntype FieldLayout is bytes32;\n\nusing FieldLayoutInstance for FieldLayout global;\n\n/**\n * Static functions for FieldLayout\n */\nlibrary FieldLayoutLib {\n  error FieldLayoutLib_InvalidLength(uint256 length);\n  error FieldLayoutLib_StaticLengthIsZero();\n  error FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n\n  /**\n   * Encode the given field layout into a single bytes32\n   */\n  function encode(uint256[] memory _staticFields, uint256 numDynamicFields) internal pure returns (FieldLayout) {\n    uint256 fieldLayout;\n    uint256 totalLength;\n    uint256 totalFields = _staticFields.length + numDynamicFields;\n    if (totalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib_InvalidLength(totalFields);\n    if (numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib_InvalidLength(numDynamicFields);\n\n    // Compute the total static length and store the field lengths in the encoded fieldLayout\n    for (uint256 i = 0; i < _staticFields.length; ) {\n      uint256 staticByteLength = _staticFields[i];\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n\n      unchecked {\n        // (safe because 28 (max _staticFields.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store lengths after the first 4 bytes (which are reserved for total length and field numbers)\n        // (safe because of the initial _staticFields.length check)\n        fieldLayout |= uint256(_staticFields[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    fieldLayout |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    fieldLayout |= _staticFields.length << LayoutOffsets.NUM_STATIC_FIELDS;\n    fieldLayout |= numDynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return FieldLayout.wrap(bytes32(fieldLayout));\n  }\n}\n\n/**\n * Instance functions for FieldLayout\n */\nlibrary FieldLayoutInstance {\n  /**\n   * Get the static byte length at the given index\n   */\n  function atIndex(FieldLayout fieldLayout, uint256 index) internal pure returns (uint256) {\n    unchecked {\n      return uint8(uint256(fieldLayout.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * BYTE_TO_BITS));\n    }\n  }\n\n  /**\n   * Get the total static byte length for the given field layout\n   */\n  function staticDataLength(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint256(FieldLayout.unwrap(fieldLayout)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * Get the number of static fields for the field layout\n   */\n  function numStaticFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * Get the number of dynamic length fields for the field layout\n   */\n  function numDynamicFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * Get the total number of fields for the field layout\n   */\n  function numFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * Check if the field layout is empty\n   */\n  function isEmpty(FieldLayout fieldLayout) internal pure returns (bool) {\n    return FieldLayout.unwrap(fieldLayout) == bytes32(0);\n  }\n\n  function validate(FieldLayout fieldLayout, bool allowEmpty) internal pure {\n    // FieldLayout must not be empty\n    if (!allowEmpty && fieldLayout.isEmpty()) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(0);\n\n    // FieldLayout must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = fieldLayout.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = fieldLayout.numStaticFields();\n    // FieldLayout must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numTotalFields);\n\n    // Static lengths must be valid\n    for (uint256 i; i < _numStaticFields; ) {\n      uint256 staticByteLength = fieldLayout.atIndex(i);\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * Unwrap the field layout\n   */\n  function unwrap(FieldLayout fieldLayout) internal pure returns (bytes32) {\n    return FieldLayout.unwrap(fieldLayout);\n  }\n}\n"
    },
    "src/CoreModule/constants_1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Shared constants */\n\n// Total byte length of an EVM word\nuint256 constant WORD_SIZE = 32;\n// Index of the last byte in an EVM word\nuint256 constant WORD_LAST_INDEX = 31;\n// Conversion for bit shifting\nuint256 constant BYTE_TO_BITS = 8;\n\n// Schema's capacity\nuint256 constant MAX_TOTAL_FIELDS = 28;\n// FieldLayout's capacity\nuint256 constant MAX_STATIC_FIELDS = 28;\n// PackedCounter's capacity\nuint256 constant MAX_DYNAMIC_FIELDS = 5;\n\n// FieldLayout and Schema have the same offsets for metadata\nlibrary LayoutOffsets {\n  uint256 internal constant TOTAL_LENGTH = (WORD_SIZE - 2) * BYTE_TO_BITS;\n  uint256 internal constant NUM_STATIC_FIELDS = (WORD_SIZE - 2 - 1) * BYTE_TO_BITS;\n  uint256 internal constant NUM_DYNAMIC_FIELDS = (WORD_SIZE - 2 - 1 - 1) * BYTE_TO_BITS;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}