{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/IDelegationControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IWorldContextConsumer, WORLD_CONTEXT_CONSUMER_INTERFACE_ID } from \"./IWorldContextConsumer.sol\";\nimport { ResourceId } from \"./WorldResourceId.sol\";\n\n/**\n * @dev Calculation for ERC-165 interface ID for the IDelegationControl interface.\n * Combines the selector of the `verify` function with the interface ID of IWorldContextConsumer.\n */\nbytes4 constant DELEGATION_CONTROL_INTERFACE_ID = IDelegationControl.verify.selector ^\n  WORLD_CONTEXT_CONSUMER_INTERFACE_ID;\n\n/**\n * @title IDelegationControl\n * @dev Interface for managing and verifying delegations within the context of a world.\n * Inherits functionalities from IWorldContextConsumer.\n */\ninterface IDelegationControl is IWorldContextConsumer {\n  function verify(address delegator, ResourceId systemId, bytes memory callData) external returns (bool);\n}\n"
    },
    "src/CoreModule/IWorldContextConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IERC165, ERC165_INTERFACE_ID } from \"./IERC165.sol\";\n\n// ERC-165 Interface ID (see https://eips.ethereum.org/EIPS/eip-165)\nbytes4 constant WORLD_CONTEXT_CONSUMER_INTERFACE_ID = IWorldContextConsumer._msgSender.selector ^\n  IWorldContextConsumer._msgValue.selector ^\n  IWorldContextConsumer._world.selector ^\n  ERC165_INTERFACE_ID;\n\ninterface IWorldContextConsumer is IERC165 {\n  function _msgSender() external view returns (address);\n\n  function _msgValue() external view returns (uint256);\n\n  function _world() external view returns (address);\n}\n"
    },
    "src/CoreModule/WorldResourceId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Bytes } from \"./Bytes.sol\";\nimport { ResourceId, ResourceIdInstance, TYPE_BITS } from \"./ResourceId.sol\";\n\nimport { ROOT_NAMESPACE, ROOT_NAME } from \"./constants.sol\";\nimport { RESOURCE_NAMESPACE, MASK_RESOURCE_NAMESPACE } from \"./worldResourceTypes.sol\";\n\nuint256 constant NAMESPACE_BITS = 14 * 8;\nuint256 constant NAME_BITS = 16 * 8;\n\nbytes16 constant ROOT_NAMESPACE_STRING = bytes16(\"ROOT_NAMESPACE\");\nbytes16 constant ROOT_NAME_STRING = bytes16(\"ROOT_NAME\");\n\nbytes32 constant NAMESPACE_MASK = bytes32(~bytes14(\"\")) >> (TYPE_BITS);\n\nlibrary WorldResourceIdLib {\n  /**\n   * Create a 32-byte resource ID from a namespace, name and type.\n   *\n   * A resource ID is a 32-byte value that uniquely identifies a resource.\n   * The first 14 bytes represent the namespace,\n   * the next 16 bytes represent the name,\n   * the last 2 bytes represent the type.\n   */\n  function encode(bytes2 typeId, bytes14 namespace, bytes16 name) internal pure returns (ResourceId) {\n    return\n      ResourceId.wrap(\n        bytes32(typeId) | (bytes32(namespace) >> TYPE_BITS) | (bytes32(name) >> (TYPE_BITS + NAMESPACE_BITS))\n      );\n  }\n\n  /**\n   * Create a 32-byte resource ID from a namespace.\n   */\n  function encodeNamespace(bytes14 namespace) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(RESOURCE_NAMESPACE) | (bytes32(namespace) >> (TYPE_BITS)));\n  }\n\n  /**\n   * Convert a padded string to a trimmed string (no trailing `null` ASCII characters)\n   */\n  function toTrimmedString(bytes16 paddedString) internal pure returns (string memory) {\n    uint256 length;\n    for (; length < 16; length++) if (Bytes.slice1(paddedString, length) == 0) break;\n    bytes memory packedSelector = abi.encodePacked(paddedString);\n    return string(Bytes.setLength(packedSelector, length));\n  }\n}\n\nlibrary WorldResourceIdInstance {\n  /**\n   * Get the namespace of a resource ID.\n   */\n  function getNamespace(ResourceId resourceId) internal pure returns (bytes14) {\n    return bytes14(ResourceId.unwrap(resourceId) << (TYPE_BITS));\n  }\n\n  /**\n   * Get the namespace resource ID corresponding to the namespace of a resource ID.\n   */\n  function getNamespaceId(ResourceId resourceId) internal pure returns (ResourceId) {\n    return ResourceId.wrap((ResourceId.unwrap(resourceId) & NAMESPACE_MASK) | MASK_RESOURCE_NAMESPACE);\n  }\n\n  /**\n   * Get the name of a resource ID.\n   */\n  function getName(ResourceId resourceId) internal pure returns (bytes16) {\n    return bytes16(ResourceId.unwrap(resourceId) << (TYPE_BITS + NAMESPACE_BITS));\n  }\n\n  /**\n   * Convert a resource ID to a string for more readable logs\n   */\n  function toString(ResourceId resourceId) internal pure returns (string memory) {\n    bytes2 resourceType = ResourceIdInstance.getType(resourceId);\n    bytes14 resourceNamespace = getNamespace(resourceId);\n    bytes16 resourceName = getName(resourceId);\n    return\n      string(\n        abi.encodePacked(\n          resourceType,\n          \":\",\n          resourceNamespace == ROOT_NAMESPACE ? ROOT_NAMESPACE_STRING : resourceNamespace,\n          \":\",\n          resourceName == ROOT_NAME ? ROOT_NAME_STRING : resourceName\n        )\n      );\n  }\n}\n"
    },
    "src/CoreModule/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/**\n * @dev Calculation for ERC-165 interface ID for the `supportsInterface` function.\n */\nbytes4 constant ERC165_INTERFACE_ID = IERC165.supportsInterface.selector;\n\n/**\n * @title IERC165\n * @dev Interface for the ERC-165 standard as described in the EIP-165.\n * Allows for contracts to be checked for their support of an interface.\n * See: https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n  /**\n   * @notice Query if a contract implements an interface.\n   * @dev Interface identification is specified in ERC-165.\n   * This function uses less than 30,000 gas.\n   * @param interfaceID The interface identifier, as specified in ERC-165.\n   * @return True if the contract implements `interfaceID` and\n   * `interfaceID` is not 0xffffffff, false otherwise.\n   */\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/CoreModule/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nlibrary Bytes {\n  /**\n   * Converts a `bytes` memory blob to a single `bytes32` memory value, starting at the given byte offset.\n   */\n  function toBytes32(bytes memory input, uint256 offset) internal pure returns (bytes32 output) {\n    assembly {\n      // input is a pointer to the start of the bytes array\n      // in memory, the first 32 bytes are the length of the array\n      // so we add 32 to the pointer to get to the start of the data\n      // then we add the start offset to get to the start of the desired word\n      output := mload(add(input, add(0x20, offset)))\n    }\n  }\n\n  /************************************************************************\n   *\n   *    UTILS\n   *\n   ************************************************************************/\n\n  function equals(bytes memory a, bytes memory b) internal pure returns (bool) {\n    if (a.length != b.length) {\n      return false;\n    }\n    return keccak256(a) == keccak256(b);\n  }\n\n  /**\n   * In-place set the length of a `bytes` memory value.\n   */\n  function setLength(bytes memory input, uint256 length) internal pure returns (bytes memory) {\n    assembly {\n      mstore(input, length)\n    }\n    return input;\n  }\n\n  /************************************************************************\n   *\n   *    SET\n   *\n   ************************************************************************/\n\n  /**\n   * Overwrite a single byte of a `bytes32` value and return the new value.\n   */\n  function setBytes1(bytes32 input, uint256 index, bytes1 overwrite) internal pure returns (bytes32 output) {\n    bytes1 mask = 0xff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * Overwrite two bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes2(bytes32 input, uint256 index, bytes2 overwrite) internal pure returns (bytes32 output) {\n    bytes2 mask = 0xffff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xffff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * Overwrite four bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes4(bytes32 input, uint256 index, bytes4 overwrite) internal pure returns (bytes32 output) {\n    bytes4 mask = 0xffffffff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xffffffff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * In-place overwrite four bytes of a `bytes memory` value.\n   */\n  function setBytes4(bytes memory input, uint256 offset, bytes4 overwrite) internal pure returns (bytes memory) {\n    bytes4 mask = 0xffffffff;\n    assembly {\n      let value := mload(add(add(input, 0x20), offset)) // load 32 bytes from input starting at offset\n      value := and(value, not(mask)) // zero out the first 4 bytes\n      value := or(value, overwrite) // set the bytes at the offset\n      mstore(add(add(input, 0x20), offset), value) // store the new value\n    }\n    return input;\n  }\n\n  /**\n   * Overwrite 5 bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes5(bytes32 input, uint256 index, bytes5 overwrite) internal pure returns (bytes32 output) {\n    bytes5 mask = bytes5(type(uint40).max);\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff...ff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * Overwrite 7 bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes7(bytes32 input, uint256 index, bytes7 overwrite) internal pure returns (bytes32 output) {\n    bytes7 mask = bytes7(type(uint56).max);\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff...ff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /************************************************************************\n   *\n   *    SLICE\n   *\n   ************************************************************************/\n\n  /** Slice bytes to bytes1 without copying data */\n  function slice1(bytes memory data, uint256 start) internal pure returns (bytes1) {\n    bytes1 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice1(bytes32 data, uint256 start) internal pure returns (bytes1) {\n    bytes1 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes2 without copying data */\n  function slice2(bytes memory data, uint256 start) internal pure returns (bytes2) {\n    bytes2 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice2(bytes32 data, uint256 start) internal pure returns (bytes2) {\n    bytes2 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes3 without copying data */\n  function slice3(bytes memory data, uint256 start) internal pure returns (bytes3) {\n    bytes3 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes4 without copying data */\n  function slice4(bytes memory data, uint256 start) internal pure returns (bytes4) {\n    bytes4 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice4(bytes32 data, uint256 start) internal pure returns (bytes4) {\n    bytes2 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes5 without copying data */\n  function slice5(bytes memory data, uint256 start) internal pure returns (bytes5) {\n    bytes5 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice5(bytes32 data, uint256 start) internal pure returns (bytes5) {\n    bytes5 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes6 without copying data */\n  function slice6(bytes memory data, uint256 start) internal pure returns (bytes6) {\n    bytes6 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes7 without copying data */\n  function slice7(bytes memory data, uint256 start) internal pure returns (bytes7) {\n    bytes7 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes8 without copying data */\n  function slice8(bytes memory data, uint256 start) internal pure returns (bytes8) {\n    bytes8 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes9 without copying data */\n  function slice9(bytes memory data, uint256 start) internal pure returns (bytes9) {\n    bytes9 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes10 without copying data */\n  function slice10(bytes memory data, uint256 start) internal pure returns (bytes10) {\n    bytes10 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes11 without copying data */\n  function slice11(bytes memory data, uint256 start) internal pure returns (bytes11) {\n    bytes11 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes12 without copying data */\n  function slice12(bytes memory data, uint256 start) internal pure returns (bytes12) {\n    bytes12 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes13 without copying data */\n  function slice13(bytes memory data, uint256 start) internal pure returns (bytes13) {\n    bytes13 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes14 without copying data */\n  function slice14(bytes memory data, uint256 start) internal pure returns (bytes14) {\n    bytes14 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes15 without copying data */\n  function slice15(bytes memory data, uint256 start) internal pure returns (bytes15) {\n    bytes15 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes16 without copying data */\n  function slice16(bytes memory data, uint256 start) internal pure returns (bytes16) {\n    bytes16 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes17 without copying data */\n  function slice17(bytes memory data, uint256 start) internal pure returns (bytes17) {\n    bytes17 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes18 without copying data */\n  function slice18(bytes memory data, uint256 start) internal pure returns (bytes18) {\n    bytes18 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes19 without copying data */\n  function slice19(bytes memory data, uint256 start) internal pure returns (bytes19) {\n    bytes19 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes20 without copying data */\n  function slice20(bytes memory data, uint256 start) internal pure returns (bytes20) {\n    bytes20 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes21 without copying data */\n  function slice21(bytes memory data, uint256 start) internal pure returns (bytes21) {\n    bytes21 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes22 without copying data */\n  function slice22(bytes memory data, uint256 start) internal pure returns (bytes22) {\n    bytes22 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes23 without copying data */\n  function slice23(bytes memory data, uint256 start) internal pure returns (bytes23) {\n    bytes23 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes24 without copying data */\n  function slice24(bytes memory data, uint256 start) internal pure returns (bytes24) {\n    bytes24 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes25 without copying data */\n  function slice25(bytes memory data, uint256 start) internal pure returns (bytes25) {\n    bytes25 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes26 without copying data */\n  function slice26(bytes memory data, uint256 start) internal pure returns (bytes26) {\n    bytes26 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes27 without copying data */\n  function slice27(bytes memory data, uint256 start) internal pure returns (bytes27) {\n    bytes27 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes28 without copying data */\n  function slice28(bytes memory data, uint256 start) internal pure returns (bytes28) {\n    bytes28 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes29 without copying data */\n  function slice29(bytes memory data, uint256 start) internal pure returns (bytes29) {\n    bytes29 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes30 without copying data */\n  function slice30(bytes memory data, uint256 start) internal pure returns (bytes30) {\n    bytes30 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes31 without copying data */\n  function slice31(bytes memory data, uint256 start) internal pure returns (bytes31) {\n    bytes31 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes32 without copying data */\n  function slice32(bytes memory data, uint256 start) internal pure returns (bytes32) {\n    bytes32 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n}\n"
    },
    "src/CoreModule/ResourceId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\ntype ResourceId is bytes32;\n\nuint256 constant TYPE_BITS = 2 * 8;\nuint256 constant NAME_BITS = 32 * 8 - TYPE_BITS;\n\nbytes32 constant TYPE_MASK = bytes32(hex\"ffff\");\n\nlibrary ResourceIdLib {\n  function encode(bytes2 typeId, bytes30 name) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(typeId) | (bytes32(name) >> TYPE_BITS));\n  }\n}\n\nlibrary ResourceIdInstance {\n  function getType(ResourceId resourceId) internal pure returns (bytes2) {\n    return bytes2(ResourceId.unwrap(resourceId));\n  }\n}\n"
    },
    "src/CoreModule/constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { ResourceId } from \"./ResourceId.sol\";\n\nimport { RESOURCE_SYSTEM, RESOURCE_NAMESPACE } from \"./worldResourceTypes.sol\";\n\nbytes14 constant ROOT_NAMESPACE = \"\";\nbytes16 constant ROOT_NAME = \"\";\n\nResourceId constant WORLD_NAMESPACE_ID = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_NAMESPACE, bytes14(\"world\"), ROOT_NAME))\n);\n\nResourceId constant ROOT_NAMESPACE_ID = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_NAMESPACE, ROOT_NAMESPACE, ROOT_NAME))\n);\n\nResourceId constant UNLIMITED_DELEGATION = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_SYSTEM, ROOT_NAMESPACE, bytes16(\"unlimited\")))\n);\n"
    },
    "src/CoreModule/worldResourceTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\nbytes2 constant RESOURCE_NAMESPACE = \"ns\";\nbytes2 constant RESOURCE_MODULE = \"md\";\nbytes2 constant RESOURCE_SYSTEM = \"sy\";\n\nbytes32 constant MASK_RESOURCE_NAMESPACE = bytes32(RESOURCE_NAMESPACE);\nbytes32 constant MASK_RESOURCE_MODULE = bytes32(RESOURCE_MODULE);\nbytes32 constant MASK_RESOURCE_SYSTEM = bytes32(RESOURCE_SYSTEM);\n"
    },
    "src/CoreModule/storeResourceTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nbytes2 constant RESOURCE_TABLE = \"tb\";\nbytes2 constant RESOURCE_OFFCHAIN_TABLE = \"ot\";\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}