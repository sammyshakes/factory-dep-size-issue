{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/IStoreHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { IERC165, ERC165_INTERFACE_ID } from \"./IERC165_0.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n// ERC-165 Interface ID (see https://eips.ethereum.org/EIPS/eip-165)\nbytes4 constant STORE_HOOK_INTERFACE_ID = IStoreHook.onBeforeSetRecord.selector ^\n  IStoreHook.onAfterSetRecord.selector ^\n  IStoreHook.onBeforeSpliceStaticData.selector ^\n  IStoreHook.onAfterSpliceStaticData.selector ^\n  IStoreHook.onBeforeSpliceDynamicData.selector ^\n  IStoreHook.onAfterSpliceDynamicData.selector ^\n  IStoreHook.onBeforeDeleteRecord.selector ^\n  IStoreHook.onAfterDeleteRecord.selector ^\n  ERC165_INTERFACE_ID;\n\ninterface IStoreHook is IERC165 {\n  error StoreHook_NotImplemented();\n\n  function onBeforeSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  function onAfterSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  function onBeforeSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  function onAfterSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  function onBeforeSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  function onAfterSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  function onBeforeDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n\n  function onAfterDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n}\n"
    },
    "src/CoreModule/FieldLayout.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { WORD_SIZE, WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants_1.sol\";\n\n// - 2 bytes for total length of all static fields\n// - 1 byte for number of static size fields\n// - 1 byte for number of dynamic size fields\n// - 28 bytes for 28 static field lengths\n// (MAX_DYNAMIC_FIELDS allows PackedCounter to pack the dynamic lengths into 1 word)\ntype FieldLayout is bytes32;\n\nusing FieldLayoutInstance for FieldLayout global;\n\n/**\n * Static functions for FieldLayout\n */\nlibrary FieldLayoutLib {\n  error FieldLayoutLib_InvalidLength(uint256 length);\n  error FieldLayoutLib_StaticLengthIsZero();\n  error FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n\n  /**\n   * Encode the given field layout into a single bytes32\n   */\n  function encode(uint256[] memory _staticFields, uint256 numDynamicFields) internal pure returns (FieldLayout) {\n    uint256 fieldLayout;\n    uint256 totalLength;\n    uint256 totalFields = _staticFields.length + numDynamicFields;\n    if (totalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib_InvalidLength(totalFields);\n    if (numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib_InvalidLength(numDynamicFields);\n\n    // Compute the total static length and store the field lengths in the encoded fieldLayout\n    for (uint256 i = 0; i < _staticFields.length; ) {\n      uint256 staticByteLength = _staticFields[i];\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n\n      unchecked {\n        // (safe because 28 (max _staticFields.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store lengths after the first 4 bytes (which are reserved for total length and field numbers)\n        // (safe because of the initial _staticFields.length check)\n        fieldLayout |= uint256(_staticFields[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    fieldLayout |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    fieldLayout |= _staticFields.length << LayoutOffsets.NUM_STATIC_FIELDS;\n    fieldLayout |= numDynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return FieldLayout.wrap(bytes32(fieldLayout));\n  }\n}\n\n/**\n * Instance functions for FieldLayout\n */\nlibrary FieldLayoutInstance {\n  /**\n   * Get the static byte length at the given index\n   */\n  function atIndex(FieldLayout fieldLayout, uint256 index) internal pure returns (uint256) {\n    unchecked {\n      return uint8(uint256(fieldLayout.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * BYTE_TO_BITS));\n    }\n  }\n\n  /**\n   * Get the total static byte length for the given field layout\n   */\n  function staticDataLength(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint256(FieldLayout.unwrap(fieldLayout)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * Get the number of static fields for the field layout\n   */\n  function numStaticFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * Get the number of dynamic length fields for the field layout\n   */\n  function numDynamicFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * Get the total number of fields for the field layout\n   */\n  function numFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * Check if the field layout is empty\n   */\n  function isEmpty(FieldLayout fieldLayout) internal pure returns (bool) {\n    return FieldLayout.unwrap(fieldLayout) == bytes32(0);\n  }\n\n  function validate(FieldLayout fieldLayout, bool allowEmpty) internal pure {\n    // FieldLayout must not be empty\n    if (!allowEmpty && fieldLayout.isEmpty()) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(0);\n\n    // FieldLayout must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = fieldLayout.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = fieldLayout.numStaticFields();\n    // FieldLayout must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numTotalFields);\n\n    // Static lengths must be valid\n    for (uint256 i; i < _numStaticFields; ) {\n      uint256 staticByteLength = fieldLayout.atIndex(i);\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * Unwrap the field layout\n   */\n  function unwrap(FieldLayout fieldLayout) internal pure returns (bytes32) {\n    return FieldLayout.unwrap(fieldLayout);\n  }\n}\n"
    },
    "src/CoreModule/IERC165_0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nbytes4 constant ERC165_INTERFACE_ID = IERC165.supportsInterface.selector;\n\n// See https://eips.ethereum.org/EIPS/eip-165\ninterface IERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/CoreModule/PackedCounter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n// - Last 7 bytes (uint56) are used for the total byte length of the dynamic data\n// - The next 5 byte (uint40) sections are used for the byte length of each field, indexed from right to left\ntype PackedCounter is bytes32;\n\nusing PackedCounterInstance for PackedCounter global;\n\n// Number of bits for the 7-byte accumulator\nuint256 constant ACC_BITS = 7 * 8;\n// Number of bits for the 5-byte sections\nuint256 constant VAL_BITS = 5 * 8;\n// Maximum value of a 5-byte section\nuint256 constant MAX_VAL = type(uint40).max;\n\n/**\n * Static functions for PackedCounter\n * The caller must ensure that the value arguments are <= MAX_VAL\n */\nlibrary PackedCounterLib {\n  function pack(uint256 a) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d + e;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n      packedCounter |= (uint256(e) << (ACC_BITS + VAL_BITS * 4));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n}\n\n/**\n * Instance functions for PackedCounter\n */\nlibrary PackedCounterInstance {\n  error PackedCounter_InvalidLength(uint256 length);\n\n  /**\n   * Decode the accumulated counter\n   * (right-most 7 bytes of packed counter)\n   */\n  function total(PackedCounter packedCounter) internal pure returns (uint256) {\n    return uint56(uint256(PackedCounter.unwrap(packedCounter)));\n  }\n\n  /**\n   * Decode the counter at the given index\n   * (right-to-left, 5 bytes per counter after the right-most 7 bytes)\n   */\n  function atIndex(PackedCounter packedCounter, uint8 index) internal pure returns (uint256) {\n    unchecked {\n      return uint40(uint256(PackedCounter.unwrap(packedCounter) >> (ACC_BITS + VAL_BITS * index)));\n    }\n  }\n\n  /**\n   * Set a counter at the given index, return the new packed counter\n   */\n  function setAtIndex(\n    PackedCounter packedCounter,\n    uint8 index,\n    uint256 newValueAtIndex\n  ) internal pure returns (PackedCounter) {\n    if (newValueAtIndex > MAX_VAL) {\n      revert PackedCounter_InvalidLength(newValueAtIndex);\n    }\n\n    uint256 rawPackedCounter = uint256(PackedCounter.unwrap(packedCounter));\n\n    // Get current lengths (total and at index)\n    uint256 accumulator = total(packedCounter);\n    uint256 currentValueAtIndex = atIndex(packedCounter, index);\n\n    // Compute the difference and update the total value\n    unchecked {\n      if (newValueAtIndex >= currentValueAtIndex) {\n        accumulator += newValueAtIndex - currentValueAtIndex;\n      } else {\n        accumulator -= currentValueAtIndex - newValueAtIndex;\n      }\n    }\n\n    // Set the new accumulated value and value at index\n    // (7 bytes total length, 5 bytes per dynamic field)\n    uint256 offset;\n    unchecked {\n      offset = ACC_BITS + VAL_BITS * index;\n    }\n    // Bitmask with 1s at the 5 bytes that form the value slot at the given index\n    uint256 mask = uint256(type(uint40).max) << offset;\n\n    // First set the last 7 bytes to 0, then set them to the new length\n    rawPackedCounter = (rawPackedCounter & ~uint256(type(uint56).max)) | accumulator;\n\n    // Zero out the value slot at the given index, then set the new value\n    rawPackedCounter = (rawPackedCounter & ~mask) | ((newValueAtIndex << offset) & mask);\n\n    return PackedCounter.wrap(bytes32(rawPackedCounter));\n  }\n\n  /*\n   * Unwrap the packed counter\n   */\n  function unwrap(PackedCounter packedCounter) internal pure returns (bytes32) {\n    return PackedCounter.unwrap(packedCounter);\n  }\n}\n"
    },
    "src/CoreModule/ResourceId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\ntype ResourceId is bytes32;\n\nuint256 constant TYPE_BITS = 2 * 8;\nuint256 constant NAME_BITS = 32 * 8 - TYPE_BITS;\n\nbytes32 constant TYPE_MASK = bytes32(hex\"ffff\");\n\nlibrary ResourceIdLib {\n  function encode(bytes2 typeId, bytes30 name) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(typeId) | (bytes32(name) >> TYPE_BITS));\n  }\n}\n\nlibrary ResourceIdInstance {\n  function getType(ResourceId resourceId) internal pure returns (bytes2) {\n    return bytes2(ResourceId.unwrap(resourceId));\n  }\n}\n"
    },
    "src/CoreModule/constants_1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Shared constants */\n\n// Total byte length of an EVM word\nuint256 constant WORD_SIZE = 32;\n// Index of the last byte in an EVM word\nuint256 constant WORD_LAST_INDEX = 31;\n// Conversion for bit shifting\nuint256 constant BYTE_TO_BITS = 8;\n\n// Schema's capacity\nuint256 constant MAX_TOTAL_FIELDS = 28;\n// FieldLayout's capacity\nuint256 constant MAX_STATIC_FIELDS = 28;\n// PackedCounter's capacity\nuint256 constant MAX_DYNAMIC_FIELDS = 5;\n\n// FieldLayout and Schema have the same offsets for metadata\nlibrary LayoutOffsets {\n  uint256 internal constant TOTAL_LENGTH = (WORD_SIZE - 2) * BYTE_TO_BITS;\n  uint256 internal constant NUM_STATIC_FIELDS = (WORD_SIZE - 2 - 1) * BYTE_TO_BITS;\n  uint256 internal constant NUM_DYNAMIC_FIELDS = (WORD_SIZE - 2 - 1 - 1) * BYTE_TO_BITS;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}