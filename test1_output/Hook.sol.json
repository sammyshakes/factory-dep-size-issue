{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/Hook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Hooks } from \"./Hooks.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n// 20 bytes address, 1 byte bitmap of enabled hooks\ntype Hook is bytes21;\n\nusing HookInstance for Hook global;\n\nlibrary HookLib {\n  /**\n   * Encode enabled hooks into a bitmap with 1 bit per hook, and pack the bitmap with the store hook address into a bytes21 value\n   */\n  function encode(address hookAddress, uint8 encodedHooks) internal pure returns (Hook) {\n    // Move the address to the leftmost 20 bytes and the bitmap to the rightmost byte\n    return Hook.wrap(bytes21(bytes20(hookAddress)) | bytes21(uint168(encodedHooks)));\n  }\n\n  /**\n   * Filter the given hook from the hook list at the given key in the given hook table\n   */\n  function filterListByAddress(\n    ResourceId hookTableId,\n    ResourceId tableWithHooks,\n    address hookAddressToRemove\n  ) internal {\n    bytes21[] memory currentHooks = Hooks._get(hookTableId, tableWithHooks);\n\n    // Initialize the new hooks array with the same length because we don't know if the hook is registered yet\n    bytes21[] memory newHooks = new bytes21[](currentHooks.length);\n\n    // Filter the array of current hooks\n    uint256 newHooksIndex;\n    unchecked {\n      for (uint256 currentHooksIndex; currentHooksIndex < currentHooks.length; currentHooksIndex++) {\n        if (Hook.wrap(currentHooks[currentHooksIndex]).getAddress() != address(hookAddressToRemove)) {\n          newHooks[newHooksIndex] = currentHooks[currentHooksIndex];\n          newHooksIndex++;\n        }\n      }\n    }\n\n    // Set the new hooks table length in place\n    // (Note: this does not update the free memory pointer)\n    assembly {\n      mstore(newHooks, newHooksIndex)\n    }\n\n    // Set the new hooks table\n    Hooks._set(hookTableId, tableWithHooks, newHooks);\n  }\n}\n\nlibrary HookInstance {\n  /**\n   * Check if the given hook type is enabled in the hook\n   */\n  function isEnabled(Hook self, uint8 hookTypes) internal pure returns (bool) {\n    return (getBitmap(self) & hookTypes) == hookTypes;\n  }\n\n  /**\n   * Get the hook's address\n   */\n  function getAddress(Hook self) internal pure returns (address) {\n    // Extract the address from the leftmost 20 bytes\n    return address(bytes20(Hook.unwrap(self)));\n  }\n\n  /**\n   * Get the store hook's bitmap\n   */\n  function getBitmap(Hook self) internal pure returns (uint8) {\n    // Extract the bitmap from the rightmost bytes\n    return uint8(uint168(Hook.unwrap(self)));\n  }\n}\n"
    },
    "src/CoreModule/Hooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import schema type\nimport { SchemaType } from \"./SchemaType.sol\";\n\n// Import store internals\nimport { IStore } from \"./IStore.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { StoreCore } from \"./StoreCore.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { SliceLib } from \"./Slice.sol\";\nimport { EncodeArray } from \"./EncodeArray.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter, PackedCounterLib } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n// Import user types\nimport { ResourceId } from \"./ResourceId.sol\";\n\nFieldLayout constant _fieldLayout = FieldLayout.wrap(\n  0x0000000100000000000000000000000000000000000000000000000000000000\n);\n\nlibrary Hooks {\n  /** Get the table values' field layout */\n  function getFieldLayout() internal pure returns (FieldLayout) {\n    return _fieldLayout;\n  }\n\n  /** Get the table's key schema */\n  function getKeySchema() internal pure returns (Schema) {\n    SchemaType[] memory _keySchema = new SchemaType[](1);\n    _keySchema[0] = SchemaType.BYTES32;\n\n    return SchemaLib.encode(_keySchema);\n  }\n\n  /** Get the table's value schema */\n  function getValueSchema() internal pure returns (Schema) {\n    SchemaType[] memory _valueSchema = new SchemaType[](1);\n    _valueSchema[0] = SchemaType.BYTES21_ARRAY;\n\n    return SchemaLib.encode(_valueSchema);\n  }\n\n  /** Get the table's key names */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"resourceId\";\n  }\n\n  /** Get the table's field names */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](1);\n    fieldNames[0] = \"hooks\";\n  }\n\n  /** Register the table with its config */\n  function register(ResourceId _tableId) internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config */\n  function _register(ResourceId _tableId) internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config (using the specified store) */\n  function register(IStore _store, ResourceId _tableId) internal {\n    _store.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Get hooks */\n  function getHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks */\n  function _getHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks (using the specified store) */\n  function getHooks(\n    IStore _store,\n    ResourceId _tableId,\n    ResourceId resourceId\n  ) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = _store.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks */\n  function get(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks */\n  function _get(ResourceId _tableId, ResourceId resourceId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks (using the specified store) */\n  function get(\n    IStore _store,\n    ResourceId _tableId,\n    ResourceId resourceId\n  ) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes memory _blob = _store.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Set hooks */\n  function setHooks(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks */\n  function _setHooks(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks (using the specified store) */\n  function setHooks(IStore _store, ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks */\n  function set(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks */\n  function _set(ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks (using the specified store) */\n  function set(IStore _store, ResourceId _tableId, ResourceId resourceId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Get the length of hooks */\n  function lengthHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks */\n  function _lengthHooks(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks (using the specified store) */\n  function lengthHooks(IStore _store, ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = _store.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks */\n  function length(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks */\n  function _length(ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks (using the specified store) */\n  function length(IStore _store, ResourceId _tableId, ResourceId resourceId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    uint256 _byteLength = _store.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function _getItemHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks (using the specified store)\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemHooks(\n    IStore _store,\n    ResourceId _tableId,\n    ResourceId resourceId,\n    uint256 _index\n  ) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = _store.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItem(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function _getItem(ResourceId _tableId, ResourceId resourceId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks (using the specified store)\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItem(\n    IStore _store,\n    ResourceId _tableId,\n    ResourceId resourceId,\n    uint256 _index\n  ) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _blob = _store.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /** Push an element to hooks */\n  function pushHooks(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks */\n  function _pushHooks(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks (using the specified store) */\n  function pushHooks(IStore _store, ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks */\n  function push(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks */\n  function _push(ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks (using the specified store) */\n  function push(IStore _store, ResourceId _tableId, ResourceId resourceId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Pop an element from hooks */\n  function popHooks(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks */\n  function _popHooks(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks (using the specified store) */\n  function popHooks(IStore _store, ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks */\n  function pop(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks */\n  function _pop(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks (using the specified store) */\n  function pop(IStore _store, ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function _updateHooks(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks (using the specified store) at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateHooks(\n    IStore _store,\n    ResourceId _tableId,\n    ResourceId resourceId,\n    uint256 _index,\n    bytes21 _element\n  ) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      _store.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function update(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function _update(ResourceId _tableId, ResourceId resourceId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks (using the specified store) at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function update(\n    IStore _store,\n    ResourceId _tableId,\n    ResourceId resourceId,\n    uint256 _index,\n    bytes21 _element\n  ) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      _store.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /** Delete all data for given keys */\n  function deleteRecord(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Delete all data for given keys */\n  function _deleteRecord(ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /** Delete all data for given keys (using the specified store) */\n  function deleteRecord(IStore _store, ResourceId _tableId, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Tightly pack dynamic data using this table's schema */\n  function encodeLengths(bytes21[] memory hooks) internal pure returns (PackedCounter _encodedLengths) {\n    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits\n    unchecked {\n      _encodedLengths = PackedCounterLib.pack(hooks.length * 21);\n    }\n  }\n\n  /** Tightly pack dynamic data using this table's schema */\n  function encodeDynamic(bytes21[] memory hooks) internal pure returns (bytes memory) {\n    return abi.encodePacked(EncodeArray.encode((hooks)));\n  }\n\n  /** Tightly pack full data using this table's field layout */\n  function encode(bytes21[] memory hooks) internal pure returns (bytes memory, PackedCounter, bytes memory) {\n    bytes memory _staticData;\n    PackedCounter _encodedLengths = encodeLengths(hooks);\n    bytes memory _dynamicData = encodeDynamic(hooks);\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Encode keys as a bytes32 array using this table's field layout */\n  function encodeKeyTuple(ResourceId resourceId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    return _keyTuple;\n  }\n}\n"
    },
    "src/CoreModule/ResourceId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\ntype ResourceId is bytes32;\n\nuint256 constant TYPE_BITS = 2 * 8;\nuint256 constant NAME_BITS = 32 * 8 - TYPE_BITS;\n\nbytes32 constant TYPE_MASK = bytes32(hex\"ffff\");\n\nlibrary ResourceIdLib {\n  function encode(bytes2 typeId, bytes30 name) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(typeId) | (bytes32(name) >> TYPE_BITS));\n  }\n}\n\nlibrary ResourceIdInstance {\n  function getType(ResourceId resourceId) internal pure returns (bytes2) {\n    return bytes2(ResourceId.unwrap(resourceId));\n  }\n}\n"
    },
    "src/CoreModule/SchemaType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nusing { getStaticByteLength } for SchemaType global;\n\n// WARNING: All enum changes MUST be mirrored for the other languages!\n// WARNING: SchemaType methods use hardcoded enum indexes, review them after any changes to the enum\n// TODO add and implement BYTES_ARRAY, STRING_ARRAY if they are needed (see https://github.com/latticexyz/mud/issues/447)\nenum SchemaType {\n  UINT8,\n  UINT16,\n  UINT24,\n  UINT32,\n  UINT40,\n  UINT48,\n  UINT56,\n  UINT64,\n  UINT72,\n  UINT80,\n  UINT88,\n  UINT96,\n  UINT104,\n  UINT112,\n  UINT120,\n  UINT128,\n  UINT136,\n  UINT144,\n  UINT152,\n  UINT160,\n  UINT168,\n  UINT176,\n  UINT184,\n  UINT192,\n  UINT200,\n  UINT208,\n  UINT216,\n  UINT224,\n  UINT232,\n  UINT240,\n  UINT248,\n  UINT256,\n  INT8,\n  INT16,\n  INT24,\n  INT32,\n  INT40,\n  INT48,\n  INT56,\n  INT64,\n  INT72,\n  INT80,\n  INT88,\n  INT96,\n  INT104,\n  INT112,\n  INT120,\n  INT128,\n  INT136,\n  INT144,\n  INT152,\n  INT160,\n  INT168,\n  INT176,\n  INT184,\n  INT192,\n  INT200,\n  INT208,\n  INT216,\n  INT224,\n  INT232,\n  INT240,\n  INT248,\n  INT256,\n  BYTES1,\n  BYTES2,\n  BYTES3,\n  BYTES4,\n  BYTES5,\n  BYTES6,\n  BYTES7,\n  BYTES8,\n  BYTES9,\n  BYTES10,\n  BYTES11,\n  BYTES12,\n  BYTES13,\n  BYTES14,\n  BYTES15,\n  BYTES16,\n  BYTES17,\n  BYTES18,\n  BYTES19,\n  BYTES20,\n  BYTES21,\n  BYTES22,\n  BYTES23,\n  BYTES24,\n  BYTES25,\n  BYTES26,\n  BYTES27,\n  BYTES28,\n  BYTES29,\n  BYTES30,\n  BYTES31,\n  BYTES32,\n  BOOL,\n  ADDRESS,\n  UINT8_ARRAY,\n  UINT16_ARRAY,\n  UINT24_ARRAY,\n  UINT32_ARRAY,\n  UINT40_ARRAY,\n  UINT48_ARRAY,\n  UINT56_ARRAY,\n  UINT64_ARRAY,\n  UINT72_ARRAY,\n  UINT80_ARRAY,\n  UINT88_ARRAY,\n  UINT96_ARRAY,\n  UINT104_ARRAY,\n  UINT112_ARRAY,\n  UINT120_ARRAY,\n  UINT128_ARRAY,\n  UINT136_ARRAY,\n  UINT144_ARRAY,\n  UINT152_ARRAY,\n  UINT160_ARRAY,\n  UINT168_ARRAY,\n  UINT176_ARRAY,\n  UINT184_ARRAY,\n  UINT192_ARRAY,\n  UINT200_ARRAY,\n  UINT208_ARRAY,\n  UINT216_ARRAY,\n  UINT224_ARRAY,\n  UINT232_ARRAY,\n  UINT240_ARRAY,\n  UINT248_ARRAY,\n  UINT256_ARRAY,\n  INT8_ARRAY,\n  INT16_ARRAY,\n  INT24_ARRAY,\n  INT32_ARRAY,\n  INT40_ARRAY,\n  INT48_ARRAY,\n  INT56_ARRAY,\n  INT64_ARRAY,\n  INT72_ARRAY,\n  INT80_ARRAY,\n  INT88_ARRAY,\n  INT96_ARRAY,\n  INT104_ARRAY,\n  INT112_ARRAY,\n  INT120_ARRAY,\n  INT128_ARRAY,\n  INT136_ARRAY,\n  INT144_ARRAY,\n  INT152_ARRAY,\n  INT160_ARRAY,\n  INT168_ARRAY,\n  INT176_ARRAY,\n  INT184_ARRAY,\n  INT192_ARRAY,\n  INT200_ARRAY,\n  INT208_ARRAY,\n  INT216_ARRAY,\n  INT224_ARRAY,\n  INT232_ARRAY,\n  INT240_ARRAY,\n  INT248_ARRAY,\n  INT256_ARRAY,\n  BYTES1_ARRAY,\n  BYTES2_ARRAY,\n  BYTES3_ARRAY,\n  BYTES4_ARRAY,\n  BYTES5_ARRAY,\n  BYTES6_ARRAY,\n  BYTES7_ARRAY,\n  BYTES8_ARRAY,\n  BYTES9_ARRAY,\n  BYTES10_ARRAY,\n  BYTES11_ARRAY,\n  BYTES12_ARRAY,\n  BYTES13_ARRAY,\n  BYTES14_ARRAY,\n  BYTES15_ARRAY,\n  BYTES16_ARRAY,\n  BYTES17_ARRAY,\n  BYTES18_ARRAY,\n  BYTES19_ARRAY,\n  BYTES20_ARRAY,\n  BYTES21_ARRAY,\n  BYTES22_ARRAY,\n  BYTES23_ARRAY,\n  BYTES24_ARRAY,\n  BYTES25_ARRAY,\n  BYTES26_ARRAY,\n  BYTES27_ARRAY,\n  BYTES28_ARRAY,\n  BYTES29_ARRAY,\n  BYTES30_ARRAY,\n  BYTES31_ARRAY,\n  BYTES32_ARRAY,\n  BOOL_ARRAY,\n  ADDRESS_ARRAY,\n  BYTES,\n  STRING\n}\n\n/**\n * Get the length of the data for the given schema type\n * (Because Solidity doesn't support constant arrays, we need to use a function)\n */\nfunction getStaticByteLength(SchemaType schemaType) pure returns (uint256) {\n  uint256 index = uint8(schemaType);\n\n  if (index < 97) {\n    // SchemaType enum elements are cyclically ordered for optimal static length lookup\n    // indexes: 00-31, 32-63, 64-95, 96, 97, ...\n    // lengths: 01-32, 01-32, 01-32, 01, 20, (the rest are 0s)\n    unchecked {\n      return (index & 31) + 1;\n    }\n  } else if (schemaType == SchemaType.ADDRESS) {\n    return 20;\n  } else {\n    // Return 0 for all dynamic types\n    return 0;\n  }\n}\n"
    },
    "src/CoreModule/IStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IStoreData } from \"./IStoreData.sol\";\nimport { IStoreRegistration } from \"./IStoreRegistration.sol\";\n\ninterface IStore is IStoreData, IStoreRegistration, IStoreErrors {}\n"
    },
    "src/CoreModule/StoreSwitch.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IStore } from \"./IStore.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { StoreCore } from \"./StoreCore.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * Call IStore functions on self or msg.sender, depending on whether the call is a delegatecall or regular call.\n */\nlibrary StoreSwitch {\n  bytes32 private constant STORAGE_SLOT = keccak256(\"mud.store.storage.StoreSwitch\");\n\n  struct StorageSlotLayout {\n    address storeAddress;\n  }\n\n  function _layout() private pure returns (StorageSlotLayout storage layout) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly {\n      layout.slot := slot\n    }\n  }\n\n  /**\n   * Get the Store address for use by other StoreSwitch functions.\n   * 0x00 is a magic number for msg.sender\n   * (which means that uninitialized storeAddress is msg.sender by default)\n   */\n  function getStoreAddress() internal view returns (address) {\n    address _storeAddress = _layout().storeAddress;\n    if (_storeAddress == address(0)) {\n      return msg.sender;\n    } else {\n      return _storeAddress;\n    }\n  }\n\n  /**\n   * Set the Store address for use by other StoreSwitch functions.\n   * If it stays uninitialized, StoreSwitch falls back to calling store methods on msg.sender.\n   */\n  function setStoreAddress(address _storeAddress) internal {\n    _layout().storeAddress = _storeAddress;\n  }\n\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.registerStoreHook(tableId, hookAddress, enabledHooksBitmap);\n    } else {\n      IStore(_storeAddress).registerStoreHook(tableId, hookAddress, enabledHooksBitmap);\n    }\n  }\n\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.unregisterStoreHook(tableId, hookAddress);\n    } else {\n      IStore(_storeAddress).unregisterStoreHook(tableId, hookAddress);\n    }\n  }\n\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout fieldLayout) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      fieldLayout = StoreCore.getFieldLayout(tableId);\n    } else {\n      fieldLayout = IStore(_storeAddress).getFieldLayout(tableId);\n    }\n  }\n\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      valueSchema = StoreCore.getValueSchema(tableId);\n    } else {\n      valueSchema = IStore(_storeAddress).getValueSchema(tableId);\n    }\n  }\n\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      keySchema = StoreCore.getKeySchema(tableId);\n    } else {\n      keySchema = IStore(_storeAddress).getKeySchema(tableId);\n    }\n  }\n\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] memory keyNames,\n    string[] memory fieldNames\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.registerTable(tableId, fieldLayout, keySchema, valueSchema, keyNames, fieldNames);\n    } else {\n      IStore(_storeAddress).registerTable(tableId, fieldLayout, keySchema, valueSchema, keyNames, fieldNames);\n    }\n  }\n\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n    } else {\n      IStore(_storeAddress).setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n    }\n  }\n\n  function spliceStaticData(ResourceId tableId, bytes32[] memory keyTuple, uint48 start, bytes memory data) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.spliceStaticData(tableId, keyTuple, start, data);\n    } else {\n      IStore(_storeAddress).spliceStaticData(tableId, keyTuple, start, data);\n    }\n  }\n\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.spliceDynamicData(tableId, keyTuple, dynamicFieldIndex, startWithinField, deleteCount, data);\n    } else {\n      IStore(_storeAddress).spliceDynamicData(\n        tableId,\n        keyTuple,\n        dynamicFieldIndex,\n        startWithinField,\n        deleteCount,\n        data\n      );\n    }\n  }\n\n  function setField(ResourceId tableId, bytes32[] memory keyTuple, uint8 fieldIndex, bytes memory data) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setField(tableId, keyTuple, fieldIndex, data);\n    } else {\n      IStore(_storeAddress).setField(tableId, keyTuple, fieldIndex, data);\n    }\n  }\n\n  function setField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      IStore(_storeAddress).setField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    }\n  }\n\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      IStore(_storeAddress).setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    }\n  }\n\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory data\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.setDynamicField(tableId, keyTuple, dynamicFieldIndex, data);\n    } else {\n      IStore(_storeAddress).setDynamicField(tableId, keyTuple, dynamicFieldIndex, data);\n    }\n  }\n\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory dataToPush\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.pushToDynamicField(tableId, keyTuple, dynamicFieldIndex, dataToPush);\n    } else {\n      IStore(_storeAddress).pushToDynamicField(tableId, keyTuple, dynamicFieldIndex, dataToPush);\n    }\n  }\n\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.popFromDynamicField(tableId, keyTuple, dynamicFieldIndex, byteLengthToPop);\n    } else {\n      IStore(_storeAddress).popFromDynamicField(tableId, keyTuple, dynamicFieldIndex, byteLengthToPop);\n    }\n  }\n\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) internal {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      StoreCore.deleteRecord(tableId, keyTuple);\n    } else {\n      IStore(_storeAddress).deleteRecord(tableId, keyTuple);\n    }\n  }\n\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal view returns (bytes memory, PackedCounter, bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getRecord(tableId, keyTuple);\n    } else {\n      return IStore(_storeAddress).getRecord(tableId, keyTuple);\n    }\n  }\n\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory, PackedCounter, bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getRecord(tableId, keyTuple, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getRecord(tableId, keyTuple, fieldLayout);\n    }\n  }\n\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getField(tableId, keyTuple, fieldIndex);\n    } else {\n      return IStore(_storeAddress).getField(tableId, keyTuple, fieldIndex);\n    }\n  }\n\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getField(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getField(tableId, keyTuple, fieldIndex, fieldLayout);\n    }\n  }\n\n  function getStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes32) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getStaticField(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getStaticField(tableId, keyTuple, fieldIndex, fieldLayout);\n    }\n  }\n\n  function getDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getDynamicField(tableId, keyTuple, dynamicFieldIndex);\n    } else {\n      return IStore(_storeAddress).getDynamicField(tableId, keyTuple, dynamicFieldIndex);\n    }\n  }\n\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (uint256) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getFieldLength(tableId, keyTuple, fieldIndex);\n    } else {\n      return IStore(_storeAddress).getFieldLength(tableId, keyTuple, fieldIndex);\n    }\n  }\n\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (uint256) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getFieldLength(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return IStore(_storeAddress).getFieldLength(tableId, keyTuple, fieldIndex, fieldLayout);\n    }\n  }\n\n  function getDynamicFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (uint256) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getDynamicFieldLength(tableId, keyTuple, dynamicFieldIndex);\n    } else {\n      return IStore(_storeAddress).getDynamicFieldLength(tableId, keyTuple, dynamicFieldIndex);\n    }\n  }\n\n  function getDynamicFieldSlice(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 start,\n    uint256 end\n  ) internal view returns (bytes memory) {\n    address _storeAddress = getStoreAddress();\n    if (_storeAddress == address(this)) {\n      return StoreCore.getDynamicFieldSlice(tableId, keyTuple, dynamicFieldIndex, start, end);\n    } else {\n      return IStore(_storeAddress).getDynamicFieldSlice(tableId, keyTuple, dynamicFieldIndex, start, end);\n    }\n  }\n}\n"
    },
    "src/CoreModule/StoreCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { STORE_VERSION } from \"./version.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { Slice, SliceLib } from \"./Slice.sol\";\nimport { StoreHooks, Tables, TablesTableId, ResourceIds, StoreHooksTableId } from \"./index.sol\";\nimport { _fieldLayout as TablesTableFieldLayout } from \"./Tables.sol\";\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { Hook, HookLib } from \"./Hook.sol\";\nimport { BEFORE_SET_RECORD, AFTER_SET_RECORD, BEFORE_SPLICE_STATIC_DATA, AFTER_SPLICE_STATIC_DATA, BEFORE_SPLICE_DYNAMIC_DATA, AFTER_SPLICE_DYNAMIC_DATA, BEFORE_DELETE_RECORD, AFTER_DELETE_RECORD } from \"./storeHookTypes.sol\";\nimport { ResourceId, ResourceIdInstance } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n/**\n * StoreCore includes implementations for all IStore methods.\n * StoreCoreInternal includes helper methods used by multiple StoreCore methods.\n * It's split into a separate library to make it clear that it's not intended to be outside StoreCore.\n */\nlibrary StoreCore {\n  using ResourceIdInstance for ResourceId;\n\n  event HelloStore(bytes32 indexed version);\n  event Store_SetRecord(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    bytes staticData,\n    PackedCounter encodedLengths,\n    bytes dynamicData\n  );\n  event Store_SpliceStaticData(ResourceId indexed tableId, bytes32[] keyTuple, uint48 start, bytes data);\n  event Store_SpliceDynamicData(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    uint48 start,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes data\n  );\n  event Store_DeleteRecord(ResourceId indexed tableId, bytes32[] keyTuple);\n\n  /**\n   * Intialize the store address to use in StoreSwitch.\n   * Consumers must call this function in their constructor.\n   */\n  function initialize() internal {\n    // StoreSwitch uses the storeAddress to decide where to write data to.\n    // If StoreSwitch is called in the context of a Store contract (storeAddress == address(this)),\n    // StoreSwitch uses internal methods to write data instead of external calls.\n    StoreSwitch.setStoreAddress(address(this));\n  }\n\n  /**\n   * Register core tables.\n   * Consumers must call this function in their constructor before setting\n   * any table data to allow indexers to decode table events.\n   */\n  function registerCoreTables() internal {\n    // Register core tables\n    Tables.register();\n    StoreHooks.register();\n    ResourceIds.register();\n  }\n\n  /************************************************************************\n   *\n   *    SCHEMA\n   *\n   ************************************************************************/\n\n  /**\n   * Get the field layout for the given table ID.\n   */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout) {\n    // Explicit check for the tables table to solve the bootstraping issue\n    if (ResourceId.unwrap(tableId) == ResourceId.unwrap(TablesTableId)) {\n      return TablesTableFieldLayout;\n    }\n    return\n      FieldLayout.wrap(\n        Storage.loadField({\n          storagePointer: StoreCoreInternal._getStaticDataLocation(TablesTableId, ResourceId.unwrap(tableId)),\n          length: 32,\n          offset: 0\n        })\n      );\n  }\n\n  /**\n   * Get the key schema for the given tableId\n   */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    keySchema = Tables._getKeySchema(tableId);\n    // key schemas can be empty for singleton tables, so we can't depend on key schema for table check\n    if (!ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * Get the schema for the given tableId\n   */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    valueSchema = Tables._getValueSchema(tableId);\n    if (valueSchema.isEmpty()) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * Register a new table the given config\n   */\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] memory keyNames,\n    string[] memory fieldNames\n  ) internal {\n    // Verify the table ID is of type RESOURCE_TABLE\n    if (tableId.getType() != RESOURCE_TABLE && tableId.getType() != RESOURCE_OFFCHAIN_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Verify the field layout is valid\n    fieldLayout.validate({ allowEmpty: false });\n\n    // Verify the schema is valid\n    keySchema.validate({ allowEmpty: true });\n    valueSchema.validate({ allowEmpty: false });\n\n    // Verify the number of key names matches the number of key schema types\n    if (keyNames.length != keySchema.numFields()) {\n      revert IStoreErrors.Store_InvalidKeyNamesLength(keySchema.numFields(), keyNames.length);\n    }\n\n    // Verify the number of value names\n    if (fieldNames.length != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidFieldNamesLength(fieldLayout.numFields(), fieldNames.length);\n    }\n\n    // Verify the number of value schema types\n    if (valueSchema.numFields() != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidValueSchemaLength(fieldLayout.numFields(), valueSchema.numFields());\n    }\n\n    // Verify there is no resource with this ID yet\n    if (ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableAlreadyExists(tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Register the table metadata\n    Tables._set(tableId, fieldLayout, keySchema, valueSchema, abi.encode(keyNames), abi.encode(fieldNames));\n\n    // Register the table ID\n    ResourceIds._setExists(tableId, true);\n  }\n\n  /************************************************************************\n   *\n   *    REGISTER HOOKS\n   *\n   ************************************************************************/\n\n  /*\n   * Register hooks to be called when a record or field is set or deleted\n   */\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) internal {\n    // Hooks are only supported for tables, not for offchain tables\n    if (tableId.getType() != RESOURCE_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    StoreHooks.push(tableId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * Unregister a hook from the given tableId\n   */\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) internal {\n    HookLib.filterListByAddress(StoreHooksTableId, tableId, address(hookAddress));\n  }\n\n  /************************************************************************\n   *\n   *    SET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * Set full data record for the given table ID and key tuple and field layout.\n   * This overload loads the field layout from storage and is exposed externally on `IStore`.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData\n  ) internal {\n    setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData, getFieldLayout(tableId));\n  }\n\n  /**\n   * Set full data record for the given table ID and key tuple and field layout.\n   * This overload allows passing in a FieldLayout and is not exposed externally on `IStore`.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) internal {\n    // Emit event to notify indexers\n    emit Store_SetRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeSetRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n\n    // Store the static data at the static data location\n    uint256 staticDataLocation = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n    uint256 memoryPointer = Memory.dataPointer(staticData);\n    Storage.store({\n      storagePointer: staticDataLocation,\n      offset: 0,\n      memoryPointer: memoryPointer,\n      length: staticData.length\n    });\n\n    // Set the dynamic data if there are dynamic fields\n    if (fieldLayout.numDynamicFields() > 0) {\n      // Store the dynamic data length at the dynamic data length location\n      uint256 dynamicDataLengthLocation = StoreCoreInternal._getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.store({ storagePointer: dynamicDataLengthLocation, data: encodedLengths.unwrap() });\n\n      // Move the memory pointer to the start of the dynamic data\n      memoryPointer = Memory.dataPointer(dynamicData);\n\n      // For every dynamic element, slice off the dynamic data and store it at the dynamic location\n      uint256 dynamicDataLocation;\n      uint256 dynamicDataLength;\n      for (uint8 i; i < fieldLayout.numDynamicFields(); ) {\n        dynamicDataLocation = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, i);\n        dynamicDataLength = encodedLengths.atIndex(i);\n        Storage.store({\n          storagePointer: dynamicDataLocation,\n          offset: 0,\n          memoryPointer: memoryPointer,\n          length: dynamicDataLength\n        });\n        memoryPointer += dynamicDataLength; // move the memory pointer to the start of the next dynamic data\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    // Call onAfterSetRecord hooks (after modifying the state)\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onAfterSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n  }\n\n  function spliceStaticData(ResourceId tableId, bytes32[] memory keyTuple, uint48 start, bytes memory data) internal {\n    uint256 location = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n\n    // Emit event to notify offchain indexers\n    emit StoreCore.Store_SpliceStaticData({ tableId: tableId, keyTuple: keyTuple, start: start, data: data });\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeSpliceStaticData hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onBeforeSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n\n    // Store the provided value in storage\n    Storage.store({ storagePointer: location, offset: start, data: data });\n\n    // Call onAfterSpliceStaticData hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onAfterSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n  }\n\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data\n  ) internal {\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: startWithinField,\n      deleteCount: deleteCount,\n      data: data,\n      previousEncodedLengths: StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple)\n    });\n  }\n\n  /**\n   * Set data for a field at the given index in a table with the given tableId, key tuple, loading the field layout from storage\n   */\n  function setField(ResourceId tableId, bytes32[] memory keyTuple, uint8 fieldIndex, bytes memory data) internal {\n    setField(tableId, keyTuple, fieldIndex, data, getFieldLayout(tableId));\n  }\n\n  /**\n   * Set data for a field at the given index in a table with the given tableId, key tuple and value field layout\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    if (fieldIndex < fieldLayout.numStaticFields()) {\n      setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      setDynamicField(tableId, keyTuple, fieldIndex - uint8(fieldLayout.numStaticFields()), data);\n    }\n  }\n\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    spliceStaticData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      start: uint48(StoreCoreInternal._getStaticDataOffset(fieldLayout, fieldIndex)),\n      data: data\n    });\n  }\n\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory data\n  ) internal {\n    // Load the previous length of the field to set from storage to compute how much data to delete\n    PackedCounter previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: 0,\n      deleteCount: previousFieldLength,\n      data: data,\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /**\n   * Delete a record for the given tableId, key tuple and value field layout.\n   * This overload loads the field layout from storage and is exposed externally on `IStore`.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) internal {\n    deleteRecord(tableId, keyTuple, getFieldLayout(tableId));\n  }\n\n  /**\n   * Delete a record for the given tableId, key tuple and value field layout.\n   * This overload allows passing in a FieldLayout and is not exposed externally on `IStore`.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) internal {\n    // Emit event to notify indexers\n    emit Store_DeleteRecord(tableId, keyTuple);\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeDeleteRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_DELETE_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeDeleteRecord(tableId, keyTuple, fieldLayout);\n      }\n    }\n\n    // Delete static data\n    uint256 staticDataLocation = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n    Storage.store({ storagePointer: staticDataLocation, offset: 0, data: new bytes(fieldLayout.staticDataLength()) });\n\n    // If there are dynamic fields, set the dynamic data length to 0.\n    // We don't need to delete the dynamic data because it will be overwritten when a new record is set.\n    if (fieldLayout.numDynamicFields() > 0) {\n      uint256 dynamicDataLengthLocation = StoreCoreInternal._getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.zero({ storagePointer: dynamicDataLengthLocation, length: 32 });\n    }\n\n    // Call onAfterDeleteRecord hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_DELETE_RECORD)) {\n        IStoreHook(hook.getAddress()).onAfterDeleteRecord(tableId, keyTuple, fieldLayout);\n      }\n    }\n  }\n\n  /**\n   * Push data to a field at the dynamic field index in a table with the given table ID and keyTuple tuple\n   */\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory dataToPush\n  ) internal {\n    // Load the previous length of the field to set from storage to compute where to start to push\n    PackedCounter previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    // Splice the dynamic data\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: uint40(previousFieldLength),\n      deleteCount: 0,\n      data: dataToPush,\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /**\n   * Pop data from a field at the dynamic field index in a table with the given table ID and key tuple\n   */\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) internal {\n    // Load the previous length of the field to set from storage to compute where to start to push\n    PackedCounter previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    // Splice the dynamic data\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: uint40(previousFieldLength - byteLengthToPop),\n      deleteCount: uint40(byteLengthToPop),\n      data: new bytes(0),\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /************************************************************************\n   *\n   *    GET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given table ID and key tuple, loading the field layout from storage\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData) {\n    return getRecord(tableId, keyTuple, getFieldLayout(tableId));\n  }\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given table ID and key tuple, with the given field layout\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData) {\n    // Get the static data length\n    uint256 staticLength = fieldLayout.staticDataLength();\n\n    // Load the static data from storage\n    staticData = StoreCoreInternal._getStaticData(tableId, keyTuple, staticLength);\n\n    // Load the dynamic data if there are dynamic fields\n    uint256 numDynamicFields = fieldLayout.numDynamicFields();\n    if (numDynamicFields > 0) {\n      // Load the encoded dynamic data length\n      encodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n\n      // Append dynamic data\n      dynamicData = new bytes(encodedLengths.total());\n      uint256 memoryPointer = Memory.dataPointer(dynamicData);\n\n      for (uint8 i; i < numDynamicFields; i++) {\n        uint256 dynamicDataLocation = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, i);\n        uint256 length = encodedLengths.atIndex(i);\n        Storage.load({ storagePointer: dynamicDataLocation, length: length, offset: 0, memoryPointer: memoryPointer });\n        // Advance memoryPointer by the length of this dynamic field\n        memoryPointer += length;\n      }\n    }\n  }\n\n  /**\n   * Get a single field from the given table ID and key tuple, loading the field layout from storage\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (bytes memory) {\n    return getField(tableId, keyTuple, fieldIndex, getFieldLayout(tableId));\n  }\n\n  /**\n   * Get a single field from the given table ID and key tuple, with the given value field layout\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory) {\n    if (fieldIndex < fieldLayout.numStaticFields()) {\n      return StoreCoreInternal._getStaticFieldBytes(tableId, keyTuple, fieldIndex, fieldLayout);\n    } else {\n      return getDynamicField(tableId, keyTuple, fieldIndex - uint8(fieldLayout.numStaticFields()));\n    }\n  }\n\n  /**\n   * Get a single static field from the given table ID and key tuple, with the given value field layout.\n   * Note: the field value is left-aligned in the returned bytes32, the rest of the word is not zeroed out.\n   * Consumers are expected to truncate the returned value as needed.\n   */\n  function getStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes32) {\n    // Get the length, storage location and offset of the static field\n    // and load the data from storage\n    return\n      Storage.loadField({\n        storagePointer: StoreCoreInternal._getStaticDataLocation(tableId, keyTuple),\n        length: fieldLayout.atIndex(fieldIndex),\n        offset: StoreCoreInternal._getStaticDataOffset(fieldLayout, fieldIndex)\n      });\n  }\n\n  /**\n   * Get a single dynamic field from the given table ID and key tuple, with the given value field layout\n   */\n  function getDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (bytes memory) {\n    // Get the storage location of the dynamic field\n    // and load the data from storage\n    return\n      Storage.load({\n        storagePointer: StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, dynamicFieldIndex),\n        length: StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple).atIndex(dynamicFieldIndex),\n        offset: 0\n      });\n  }\n\n  /**\n   * Get the byte length of a single field from the given table ID and key tuple\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) internal view returns (uint256) {\n    return getFieldLength(tableId, keyTuple, fieldIndex, getFieldLayout(tableId));\n  }\n\n  /**\n   * Get the byte length of a single field from the given table ID and key tuple, with the given value field layout\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (uint256) {\n    uint8 numStaticFields = uint8(fieldLayout.numStaticFields());\n    if (fieldIndex < numStaticFields) {\n      return fieldLayout.atIndex(fieldIndex);\n    } else {\n      return getDynamicFieldLength(tableId, keyTuple, fieldIndex - numStaticFields);\n    }\n  }\n\n  /**\n   * Get the byte length of a single dynamic field from the given table ID and key tuple\n   */\n  function getDynamicFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal view returns (uint256) {\n    return StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple).atIndex(dynamicFieldIndex);\n  }\n\n  /**\n   * Get a byte slice (including start, excluding end) of a single dynamic field from the given table ID and key tuple, with the given value field layout.\n   */\n  function getDynamicFieldSlice(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 start,\n    uint256 end\n  ) internal view returns (bytes memory) {\n    // Verify the accessed data is within the bounds of the dynamic field.\n    // This is necessary because we don't delete the dynamic data when a record is deleted,\n    // but only decrease its length.\n    PackedCounter encodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint256 fieldLength = encodedLengths.atIndex(dynamicFieldIndex);\n    if (start >= fieldLength || end > fieldLength) {\n      revert IStoreErrors.Store_IndexOutOfBounds(fieldLength, start >= fieldLength ? start : end - 1);\n    }\n\n    // Get the length and storage location of the dynamic field\n    uint256 location = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, dynamicFieldIndex);\n\n    return Storage.load({ storagePointer: location, length: end - start, offset: start });\n  }\n}\n\nlibrary StoreCoreInternal {\n  using ResourceIdInstance for ResourceId;\n\n  bytes32 internal constant SLOT = keccak256(\"mud.store\");\n  bytes32 internal constant DYNMAIC_DATA_SLOT = keccak256(\"mud.store.dynamicData\");\n  bytes32 internal constant DYNAMIC_DATA_LENGTH_SLOT = keccak256(\"mud.store.dynamicDataLength\");\n\n  /************************************************************************\n   *\n   *    SET DATA\n   *\n   ************************************************************************/\n\n  function _spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data,\n    PackedCounter previousEncodedLengths\n  ) internal {\n    // Splicing dynamic data is not supported for offchain tables, because it\n    // requires reading the previous encoded lengths from storage\n    if (tableId.getType() != RESOURCE_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    uint256 previousFieldLength = previousEncodedLengths.atIndex(dynamicFieldIndex);\n    uint256 updatedFieldLength = previousFieldLength - deleteCount + data.length;\n\n    // If the total length of the field is changed, the data has to be appended/removed at the end of the field.\n    // Otherwise offchain indexers would shift the data after inserted data, while onchain the data is truncated at the end.\n    if (previousFieldLength != updatedFieldLength && startWithinField + deleteCount != previousFieldLength) {\n      revert IStoreErrors.Store_InvalidSplice(startWithinField, deleteCount, uint40(previousFieldLength));\n    }\n\n    // The start index can't be larger than the previous length of the field\n    if (startWithinField > previousFieldLength) {\n      revert IStoreErrors.Store_IndexOutOfBounds(previousFieldLength, startWithinField);\n    }\n\n    // Update the encoded length\n    PackedCounter updatedEncodedLengths = previousEncodedLengths.setAtIndex(dynamicFieldIndex, updatedFieldLength);\n\n    {\n      // Compute start index for the splice\n      uint256 start = startWithinField;\n      unchecked {\n        // (safe because it's a few uint40 values, which can't overflow uint48)\n        for (uint8 i; i < dynamicFieldIndex; i++) {\n          start += previousEncodedLengths.atIndex(i);\n        }\n      }\n\n      // Emit event to notify offchain indexers\n      emit StoreCore.Store_SpliceDynamicData({\n        tableId: tableId,\n        keyTuple: keyTuple,\n        start: uint48(start),\n        deleteCount: deleteCount,\n        encodedLengths: updatedEncodedLengths,\n        data: data\n      });\n    }\n\n    // Call onBeforeSpliceDynamicData hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SPLICE_DYNAMIC_DATA)) {\n        IStoreHook(hook.getAddress()).onBeforeSpliceDynamicData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          dynamicFieldIndex: dynamicFieldIndex,\n          startWithinField: startWithinField,\n          deleteCount: deleteCount,\n          encodedLengths: updatedEncodedLengths,\n          data: data\n        });\n      }\n    }\n\n    // Store the updated encoded lengths in storage\n    if (previousFieldLength != updatedFieldLength) {\n      uint256 dynamicSchemaLengthSlot = _getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.store({ storagePointer: dynamicSchemaLengthSlot, data: updatedEncodedLengths.unwrap() });\n    }\n\n    // Store the provided value in storage\n    {\n      uint256 dynamicDataLocation = _getDynamicDataLocation(tableId, keyTuple, dynamicFieldIndex);\n      Storage.store({ storagePointer: dynamicDataLocation, offset: startWithinField, data: data });\n    }\n\n    // Call onAfterSpliceDynamicData hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SPLICE_DYNAMIC_DATA)) {\n        IStoreHook(hook.getAddress()).onAfterSpliceDynamicData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          dynamicFieldIndex: dynamicFieldIndex,\n          startWithinField: startWithinField,\n          deleteCount: deleteCount,\n          encodedLengths: updatedEncodedLengths,\n          data: data\n        });\n      }\n    }\n  }\n\n  /************************************************************************\n   *\n   *    GET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * Get full static data for the given table ID and key tuple, with the given static length\n   */\n  function _getStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint256 length\n  ) internal view returns (bytes memory) {\n    if (length == 0) return \"\";\n\n    // Load the data from storage\n    uint256 location = _getStaticDataLocation(tableId, keyTuple);\n    return Storage.load({ storagePointer: location, length: length, offset: 0 });\n  }\n\n  /**\n   * Get a single static field from the given table ID and key tuple, with the given value field layout.\n   * Returns dynamic bytes memory in the size of the field.\n   */\n  function _getStaticFieldBytes(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory) {\n    // Get the length, storage location and offset of the static field\n    // and load the data from storage\n    return\n      Storage.load({\n        storagePointer: StoreCoreInternal._getStaticDataLocation(tableId, keyTuple),\n        length: fieldLayout.atIndex(fieldIndex),\n        offset: StoreCoreInternal._getStaticDataOffset(fieldLayout, fieldIndex)\n      });\n  }\n\n  /************************************************************************\n   *\n   *    HELPER FUNCTIONS\n   *\n   ************************************************************************/\n\n  /////////////////////////////////////////////////////////////////////////\n  //    STATIC DATA\n  /////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Compute the storage location based on tableId id and key tuple\n   */\n  function _getStaticDataLocation(ResourceId tableId, bytes32[] memory keyTuple) internal pure returns (uint256) {\n    return uint256(SLOT ^ keccak256(abi.encodePacked(tableId, keyTuple)));\n  }\n\n  /**\n   * Compute the storage location based on tableId id and key (equivalent to keyTuple = [key])\n   */\n  function _getStaticDataLocation(ResourceId tableId, bytes32 key) internal pure returns (uint256) {\n    return uint256(SLOT ^ keccak256(abi.encodePacked(tableId, key)));\n  }\n\n  /**\n   * Get storage offset for the given value field layout and (static length) index\n   */\n  function _getStaticDataOffset(FieldLayout fieldLayout, uint8 fieldIndex) internal pure returns (uint256) {\n    uint256 offset = 0;\n    for (uint256 i; i < fieldIndex; i++) {\n      offset += fieldLayout.atIndex(i);\n    }\n    return offset;\n  }\n\n  /////////////////////////////////////////////////////////////////////////\n  //    DYNAMIC DATA\n  /////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Compute the storage location based on tableId id and index tuple\n   */\n  function _getDynamicDataLocation(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) internal pure returns (uint256) {\n    return uint256(DYNMAIC_DATA_SLOT ^ bytes1(dynamicFieldIndex) ^ keccak256(abi.encodePacked(tableId, keyTuple)));\n  }\n\n  /**\n   * Compute the storage location for the length of the dynamic data\n   */\n  function _getDynamicDataLengthLocation(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal pure returns (uint256) {\n    return uint256(DYNAMIC_DATA_LENGTH_SLOT ^ keccak256(abi.encodePacked(tableId, keyTuple)));\n  }\n\n  /**\n   * Load the encoded dynamic data length from storage for the given table ID and key tuple\n   */\n  function _loadEncodedDynamicDataLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal view returns (PackedCounter) {\n    // Load dynamic data length from storage\n    return PackedCounter.wrap(Storage.load({ storagePointer: _getDynamicDataLengthLocation(tableId, keyTuple) }));\n  }\n}\n"
    },
    "src/CoreModule/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nlibrary Bytes {\n  /**\n   * Converts a `bytes` memory blob to a single `bytes32` memory value, starting at the given byte offset.\n   */\n  function toBytes32(bytes memory input, uint256 offset) internal pure returns (bytes32 output) {\n    assembly {\n      // input is a pointer to the start of the bytes array\n      // in memory, the first 32 bytes are the length of the array\n      // so we add 32 to the pointer to get to the start of the data\n      // then we add the start offset to get to the start of the desired word\n      output := mload(add(input, add(0x20, offset)))\n    }\n  }\n\n  /************************************************************************\n   *\n   *    UTILS\n   *\n   ************************************************************************/\n\n  function equals(bytes memory a, bytes memory b) internal pure returns (bool) {\n    if (a.length != b.length) {\n      return false;\n    }\n    return keccak256(a) == keccak256(b);\n  }\n\n  /**\n   * In-place set the length of a `bytes` memory value.\n   */\n  function setLength(bytes memory input, uint256 length) internal pure returns (bytes memory) {\n    assembly {\n      mstore(input, length)\n    }\n    return input;\n  }\n\n  /************************************************************************\n   *\n   *    SET\n   *\n   ************************************************************************/\n\n  /**\n   * Overwrite a single byte of a `bytes32` value and return the new value.\n   */\n  function setBytes1(bytes32 input, uint256 index, bytes1 overwrite) internal pure returns (bytes32 output) {\n    bytes1 mask = 0xff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * Overwrite two bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes2(bytes32 input, uint256 index, bytes2 overwrite) internal pure returns (bytes32 output) {\n    bytes2 mask = 0xffff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xffff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * Overwrite four bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes4(bytes32 input, uint256 index, bytes4 overwrite) internal pure returns (bytes32 output) {\n    bytes4 mask = 0xffffffff;\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xffffffff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * In-place overwrite four bytes of a `bytes memory` value.\n   */\n  function setBytes4(bytes memory input, uint256 offset, bytes4 overwrite) internal pure returns (bytes memory) {\n    bytes4 mask = 0xffffffff;\n    assembly {\n      let value := mload(add(add(input, 0x20), offset)) // load 32 bytes from input starting at offset\n      value := and(value, not(mask)) // zero out the first 4 bytes\n      value := or(value, overwrite) // set the bytes at the offset\n      mstore(add(add(input, 0x20), offset), value) // store the new value\n    }\n    return input;\n  }\n\n  /**\n   * Overwrite 5 bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes5(bytes32 input, uint256 index, bytes5 overwrite) internal pure returns (bytes32 output) {\n    bytes5 mask = bytes5(type(uint40).max);\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff...ff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /**\n   * Overwrite 7 bytes of a `bytes32` value and return the new value.\n   */\n  function setBytes7(bytes32 input, uint256 index, bytes7 overwrite) internal pure returns (bytes32 output) {\n    bytes7 mask = bytes7(type(uint56).max);\n    assembly {\n      mask := shr(mul(8, index), mask) // create a mask by shifting 0xff...ff right by index bytes\n      output := and(input, not(mask)) // zero out the byte at index\n      output := or(output, shr(mul(8, index), overwrite)) // set the byte at index\n    }\n    return output;\n  }\n\n  /************************************************************************\n   *\n   *    SLICE\n   *\n   ************************************************************************/\n\n  /** Slice bytes to bytes1 without copying data */\n  function slice1(bytes memory data, uint256 start) internal pure returns (bytes1) {\n    bytes1 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice1(bytes32 data, uint256 start) internal pure returns (bytes1) {\n    bytes1 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes2 without copying data */\n  function slice2(bytes memory data, uint256 start) internal pure returns (bytes2) {\n    bytes2 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice2(bytes32 data, uint256 start) internal pure returns (bytes2) {\n    bytes2 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes3 without copying data */\n  function slice3(bytes memory data, uint256 start) internal pure returns (bytes3) {\n    bytes3 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes4 without copying data */\n  function slice4(bytes memory data, uint256 start) internal pure returns (bytes4) {\n    bytes4 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice4(bytes32 data, uint256 start) internal pure returns (bytes4) {\n    bytes2 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes5 without copying data */\n  function slice5(bytes memory data, uint256 start) internal pure returns (bytes5) {\n    bytes5 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  function slice5(bytes32 data, uint256 start) internal pure returns (bytes5) {\n    bytes5 output;\n    assembly {\n      output := shl(mul(8, start), data)\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes6 without copying data */\n  function slice6(bytes memory data, uint256 start) internal pure returns (bytes6) {\n    bytes6 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes7 without copying data */\n  function slice7(bytes memory data, uint256 start) internal pure returns (bytes7) {\n    bytes7 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes8 without copying data */\n  function slice8(bytes memory data, uint256 start) internal pure returns (bytes8) {\n    bytes8 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes9 without copying data */\n  function slice9(bytes memory data, uint256 start) internal pure returns (bytes9) {\n    bytes9 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes10 without copying data */\n  function slice10(bytes memory data, uint256 start) internal pure returns (bytes10) {\n    bytes10 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes11 without copying data */\n  function slice11(bytes memory data, uint256 start) internal pure returns (bytes11) {\n    bytes11 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes12 without copying data */\n  function slice12(bytes memory data, uint256 start) internal pure returns (bytes12) {\n    bytes12 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes13 without copying data */\n  function slice13(bytes memory data, uint256 start) internal pure returns (bytes13) {\n    bytes13 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes14 without copying data */\n  function slice14(bytes memory data, uint256 start) internal pure returns (bytes14) {\n    bytes14 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes15 without copying data */\n  function slice15(bytes memory data, uint256 start) internal pure returns (bytes15) {\n    bytes15 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes16 without copying data */\n  function slice16(bytes memory data, uint256 start) internal pure returns (bytes16) {\n    bytes16 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes17 without copying data */\n  function slice17(bytes memory data, uint256 start) internal pure returns (bytes17) {\n    bytes17 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes18 without copying data */\n  function slice18(bytes memory data, uint256 start) internal pure returns (bytes18) {\n    bytes18 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes19 without copying data */\n  function slice19(bytes memory data, uint256 start) internal pure returns (bytes19) {\n    bytes19 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes20 without copying data */\n  function slice20(bytes memory data, uint256 start) internal pure returns (bytes20) {\n    bytes20 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes21 without copying data */\n  function slice21(bytes memory data, uint256 start) internal pure returns (bytes21) {\n    bytes21 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes22 without copying data */\n  function slice22(bytes memory data, uint256 start) internal pure returns (bytes22) {\n    bytes22 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes23 without copying data */\n  function slice23(bytes memory data, uint256 start) internal pure returns (bytes23) {\n    bytes23 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes24 without copying data */\n  function slice24(bytes memory data, uint256 start) internal pure returns (bytes24) {\n    bytes24 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes25 without copying data */\n  function slice25(bytes memory data, uint256 start) internal pure returns (bytes25) {\n    bytes25 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes26 without copying data */\n  function slice26(bytes memory data, uint256 start) internal pure returns (bytes26) {\n    bytes26 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes27 without copying data */\n  function slice27(bytes memory data, uint256 start) internal pure returns (bytes27) {\n    bytes27 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes28 without copying data */\n  function slice28(bytes memory data, uint256 start) internal pure returns (bytes28) {\n    bytes28 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes29 without copying data */\n  function slice29(bytes memory data, uint256 start) internal pure returns (bytes29) {\n    bytes29 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes30 without copying data */\n  function slice30(bytes memory data, uint256 start) internal pure returns (bytes30) {\n    bytes30 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes31 without copying data */\n  function slice31(bytes memory data, uint256 start) internal pure returns (bytes31) {\n    bytes31 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n\n  /** Slice bytes to bytes32 without copying data */\n  function slice32(bytes memory data, uint256 start) internal pure returns (bytes32) {\n    bytes32 output;\n    assembly {\n      output := mload(add(add(data, 0x20), start))\n    }\n    return output;\n  }\n}\n"
    },
    "src/CoreModule/Memory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\n\nlibrary Memory {\n  /**\n   * In dynamic arrays the first word stores the length of data, after which comes the data.\n   * Example: 0x40 0x01 0x02\n   *          ^len ^data\n   */\n  function dataPointer(bytes memory data) internal pure returns (uint256 memoryPointer) {\n    assembly {\n      memoryPointer := add(data, 0x20)\n    }\n  }\n\n  function copy(uint256 fromPointer, uint256 toPointer, uint256 length) internal pure {\n    // Copy 32-byte chunks\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(toPointer, mload(fromPointer))\n      }\n      // Safe because total addition will be <= length (ptr+len is implicitly safe)\n      unchecked {\n        toPointer += 32;\n        fromPointer += 32;\n        length -= 32;\n      }\n    }\n    if (length == 0) return;\n\n    // Copy the 0-31 length tail\n    uint256 mask = leftMask(length);\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(\n        toPointer,\n        or(\n          // store the left part\n          and(mload(fromPointer), mask),\n          // preserve the right part\n          and(mload(toPointer), not(mask))\n        )\n      )\n    }\n  }\n}\n"
    },
    "src/CoreModule/Slice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Memory } from \"./Memory.sol\";\nimport { DecodeSlice } from \"./DecodeSlice.sol\";\n\n// Acknowledgements:\n// Based on @dk1a's Slice.sol library (https://github.com/dk1a/solidity-stringutils/blob/main/src/Slice.sol)\n\n// First 16 bytes are the pointer to the data, followed by 16 bytes of data length.\ntype Slice is uint256;\n\nusing SliceInstance for Slice global;\nusing DecodeSlice for Slice global;\n\n/**\n * @title Static functions for Slice\n */\nlibrary SliceLib {\n  error Slice_OutOfBounds(bytes data, uint256 start, uint256 end);\n\n  uint256 constant MASK_LEN = uint256(type(uint128).max);\n  uint256 constant MASK_PTR = uint256(type(uint128).max) << 128;\n\n  /**\n   * @dev Converts a bytes array to a slice (without copying data)\n   */\n  function fromBytes(bytes memory data) internal pure returns (Slice) {\n    uint256 _pointer;\n    assembly {\n      _pointer := add(data, 0x20) // pointer to first data byte\n    }\n\n    // Pointer is stored in upper 128 bits, length is stored in lower 128 bits\n    return Slice.wrap((_pointer << 128) | (data.length & MASK_LEN));\n  }\n\n  /**\n   * @dev Subslice a bytes array using the given start index until the end of the array (without copying data)\n   */\n  function getSubslice(bytes memory data, uint256 start) internal pure returns (Slice) {\n    return getSubslice(data, start, data.length);\n  }\n\n  /**\n   * @dev Subslice a bytes array using the given indexes (without copying data)\n   * The start index is inclusive, the end index is exclusive\n   */\n  function getSubslice(bytes memory data, uint256 start, uint256 end) internal pure returns (Slice) {\n    // TODO this check helps catch bugs and can eventually be removed\n    if (!(start <= end && end <= data.length)) revert Slice_OutOfBounds(data, start, end);\n\n    uint256 _pointer;\n    assembly {\n      _pointer := add(data, 0x20) // pointer to first data byte\n    }\n\n    _pointer += start;\n    uint256 _len = end - start;\n\n    // Pointer is stored in upper 128 bits, length is stored in lower 128 bits\n    return Slice.wrap((_pointer << 128) | (_len & MASK_LEN));\n  }\n}\n\n/**\n * @title Instance functions for Slice\n */\nlibrary SliceInstance {\n  /**\n   * @dev Returns the pointer to the start of a slice\n   */\n  function pointer(Slice self) internal pure returns (uint256) {\n    return Slice.unwrap(self) >> 128;\n  }\n\n  /**\n   * @dev Returns the slice length in bytes\n   */\n  function length(Slice self) internal pure returns (uint256) {\n    return Slice.unwrap(self) & SliceLib.MASK_LEN;\n  }\n\n  /**\n   * @dev Copies the slice to a new bytes array\n   * The slice will NOT point to the new bytes array\n   */\n  function toBytes(Slice self) internal pure returns (bytes memory data) {\n    uint256 fromPointer = pointer(self);\n    uint256 _length = length(self);\n\n    // Allocate a new bytes array and get the pointer to it\n    data = new bytes(_length);\n    uint256 toPointer;\n    assembly {\n      toPointer := add(data, 32)\n    }\n    // Copy the slice contents to the array\n    Memory.copy(fromPointer, toPointer, _length);\n  }\n\n  function toBytes32(Slice self) internal pure returns (bytes32 result) {\n    uint256 memoryPointer = self.pointer();\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := mload(memoryPointer)\n    }\n    return result;\n  }\n}\n"
    },
    "src/CoreModule/EncodeArray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */\nimport { TightCoder } from \"./TightCoder.sol\";\n\nlibrary EncodeArray {\n  function encode(uint8[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 248);\n  }\n\n  function encode(uint16[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 2, 240);\n  }\n\n  function encode(uint24[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 3, 232);\n  }\n\n  function encode(uint32[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 4, 224);\n  }\n\n  function encode(uint40[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 5, 216);\n  }\n\n  function encode(uint48[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 6, 208);\n  }\n\n  function encode(uint56[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 7, 200);\n  }\n\n  function encode(uint64[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 8, 192);\n  }\n\n  function encode(uint72[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 9, 184);\n  }\n\n  function encode(uint80[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 10, 176);\n  }\n\n  function encode(uint88[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 11, 168);\n  }\n\n  function encode(uint96[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 12, 160);\n  }\n\n  function encode(uint104[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 13, 152);\n  }\n\n  function encode(uint112[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 14, 144);\n  }\n\n  function encode(uint120[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 15, 136);\n  }\n\n  function encode(uint128[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 16, 128);\n  }\n\n  function encode(uint136[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 17, 120);\n  }\n\n  function encode(uint144[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 18, 112);\n  }\n\n  function encode(uint152[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 19, 104);\n  }\n\n  function encode(uint160[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 96);\n  }\n\n  function encode(uint168[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 21, 88);\n  }\n\n  function encode(uint176[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 22, 80);\n  }\n\n  function encode(uint184[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 23, 72);\n  }\n\n  function encode(uint192[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 24, 64);\n  }\n\n  function encode(uint200[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 25, 56);\n  }\n\n  function encode(uint208[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 26, 48);\n  }\n\n  function encode(uint216[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 27, 40);\n  }\n\n  function encode(uint224[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 28, 32);\n  }\n\n  function encode(uint232[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 29, 24);\n  }\n\n  function encode(uint240[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 30, 16);\n  }\n\n  function encode(uint248[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 31, 8);\n  }\n\n  function encode(uint256[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 32, 0);\n  }\n\n  function encode(int8[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 248);\n  }\n\n  function encode(int16[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 2, 240);\n  }\n\n  function encode(int24[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 3, 232);\n  }\n\n  function encode(int32[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 4, 224);\n  }\n\n  function encode(int40[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 5, 216);\n  }\n\n  function encode(int48[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 6, 208);\n  }\n\n  function encode(int56[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 7, 200);\n  }\n\n  function encode(int64[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 8, 192);\n  }\n\n  function encode(int72[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 9, 184);\n  }\n\n  function encode(int80[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 10, 176);\n  }\n\n  function encode(int88[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 11, 168);\n  }\n\n  function encode(int96[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 12, 160);\n  }\n\n  function encode(int104[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 13, 152);\n  }\n\n  function encode(int112[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 14, 144);\n  }\n\n  function encode(int120[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 15, 136);\n  }\n\n  function encode(int128[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 16, 128);\n  }\n\n  function encode(int136[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 17, 120);\n  }\n\n  function encode(int144[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 18, 112);\n  }\n\n  function encode(int152[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 19, 104);\n  }\n\n  function encode(int160[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 96);\n  }\n\n  function encode(int168[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 21, 88);\n  }\n\n  function encode(int176[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 22, 80);\n  }\n\n  function encode(int184[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 23, 72);\n  }\n\n  function encode(int192[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 24, 64);\n  }\n\n  function encode(int200[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 25, 56);\n  }\n\n  function encode(int208[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 26, 48);\n  }\n\n  function encode(int216[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 27, 40);\n  }\n\n  function encode(int224[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 28, 32);\n  }\n\n  function encode(int232[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 29, 24);\n  }\n\n  function encode(int240[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 30, 16);\n  }\n\n  function encode(int248[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 31, 8);\n  }\n\n  function encode(int256[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 32, 0);\n  }\n\n  function encode(bytes1[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 0);\n  }\n\n  function encode(bytes2[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 2, 0);\n  }\n\n  function encode(bytes3[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 3, 0);\n  }\n\n  function encode(bytes4[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 4, 0);\n  }\n\n  function encode(bytes5[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 5, 0);\n  }\n\n  function encode(bytes6[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 6, 0);\n  }\n\n  function encode(bytes7[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 7, 0);\n  }\n\n  function encode(bytes8[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 8, 0);\n  }\n\n  function encode(bytes9[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 9, 0);\n  }\n\n  function encode(bytes10[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 10, 0);\n  }\n\n  function encode(bytes11[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 11, 0);\n  }\n\n  function encode(bytes12[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 12, 0);\n  }\n\n  function encode(bytes13[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 13, 0);\n  }\n\n  function encode(bytes14[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 14, 0);\n  }\n\n  function encode(bytes15[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 15, 0);\n  }\n\n  function encode(bytes16[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 16, 0);\n  }\n\n  function encode(bytes17[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 17, 0);\n  }\n\n  function encode(bytes18[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 18, 0);\n  }\n\n  function encode(bytes19[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 19, 0);\n  }\n\n  function encode(bytes20[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 0);\n  }\n\n  function encode(bytes21[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 21, 0);\n  }\n\n  function encode(bytes22[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 22, 0);\n  }\n\n  function encode(bytes23[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 23, 0);\n  }\n\n  function encode(bytes24[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 24, 0);\n  }\n\n  function encode(bytes25[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 25, 0);\n  }\n\n  function encode(bytes26[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 26, 0);\n  }\n\n  function encode(bytes27[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 27, 0);\n  }\n\n  function encode(bytes28[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 28, 0);\n  }\n\n  function encode(bytes29[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 29, 0);\n  }\n\n  function encode(bytes30[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 30, 0);\n  }\n\n  function encode(bytes31[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 31, 0);\n  }\n\n  function encode(bytes32[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 32, 0);\n  }\n\n  function encode(bool[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 1, 248);\n  }\n\n  function encode(address[] memory _input) internal pure returns (bytes memory) {\n    bytes32[] memory _genericArray;\n    assembly {\n      _genericArray := _input\n    }\n    return TightCoder.encode(_genericArray, 20, 96);\n  }\n}\n"
    },
    "src/CoreModule/FieldLayout.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { WORD_SIZE, WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants_1.sol\";\n\n// - 2 bytes for total length of all static fields\n// - 1 byte for number of static size fields\n// - 1 byte for number of dynamic size fields\n// - 28 bytes for 28 static field lengths\n// (MAX_DYNAMIC_FIELDS allows PackedCounter to pack the dynamic lengths into 1 word)\ntype FieldLayout is bytes32;\n\nusing FieldLayoutInstance for FieldLayout global;\n\n/**\n * Static functions for FieldLayout\n */\nlibrary FieldLayoutLib {\n  error FieldLayoutLib_InvalidLength(uint256 length);\n  error FieldLayoutLib_StaticLengthIsZero();\n  error FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n\n  /**\n   * Encode the given field layout into a single bytes32\n   */\n  function encode(uint256[] memory _staticFields, uint256 numDynamicFields) internal pure returns (FieldLayout) {\n    uint256 fieldLayout;\n    uint256 totalLength;\n    uint256 totalFields = _staticFields.length + numDynamicFields;\n    if (totalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib_InvalidLength(totalFields);\n    if (numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib_InvalidLength(numDynamicFields);\n\n    // Compute the total static length and store the field lengths in the encoded fieldLayout\n    for (uint256 i = 0; i < _staticFields.length; ) {\n      uint256 staticByteLength = _staticFields[i];\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n\n      unchecked {\n        // (safe because 28 (max _staticFields.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store lengths after the first 4 bytes (which are reserved for total length and field numbers)\n        // (safe because of the initial _staticFields.length check)\n        fieldLayout |= uint256(_staticFields[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    fieldLayout |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    fieldLayout |= _staticFields.length << LayoutOffsets.NUM_STATIC_FIELDS;\n    fieldLayout |= numDynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return FieldLayout.wrap(bytes32(fieldLayout));\n  }\n}\n\n/**\n * Instance functions for FieldLayout\n */\nlibrary FieldLayoutInstance {\n  /**\n   * Get the static byte length at the given index\n   */\n  function atIndex(FieldLayout fieldLayout, uint256 index) internal pure returns (uint256) {\n    unchecked {\n      return uint8(uint256(fieldLayout.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * BYTE_TO_BITS));\n    }\n  }\n\n  /**\n   * Get the total static byte length for the given field layout\n   */\n  function staticDataLength(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint256(FieldLayout.unwrap(fieldLayout)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * Get the number of static fields for the field layout\n   */\n  function numStaticFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * Get the number of dynamic length fields for the field layout\n   */\n  function numDynamicFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * Get the total number of fields for the field layout\n   */\n  function numFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * Check if the field layout is empty\n   */\n  function isEmpty(FieldLayout fieldLayout) internal pure returns (bool) {\n    return FieldLayout.unwrap(fieldLayout) == bytes32(0);\n  }\n\n  function validate(FieldLayout fieldLayout, bool allowEmpty) internal pure {\n    // FieldLayout must not be empty\n    if (!allowEmpty && fieldLayout.isEmpty()) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(0);\n\n    // FieldLayout must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = fieldLayout.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = fieldLayout.numStaticFields();\n    // FieldLayout must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numTotalFields);\n\n    // Static lengths must be valid\n    for (uint256 i; i < _numStaticFields; ) {\n      uint256 staticByteLength = fieldLayout.atIndex(i);\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * Unwrap the field layout\n   */\n  function unwrap(FieldLayout fieldLayout) internal pure returns (bytes32) {\n    return FieldLayout.unwrap(fieldLayout);\n  }\n}\n"
    },
    "src/CoreModule/Schema.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { SchemaType } from \"./SchemaType.sol\";\n\nimport { WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants_1.sol\";\n\n// - 2 bytes static length of the schema\n// - 1 byte for number of static size fields\n// - 1 byte for number of dynamic size fields\n// - 28 bytes for 28 schema types (MAX_DYNAMIC_FIELDS allows us to pack the lengths into 1 word)\ntype Schema is bytes32;\n\nusing SchemaInstance for Schema global;\n\n/**\n * Static functions for Schema\n */\nlibrary SchemaLib {\n  error SchemaLib_InvalidLength(uint256 length);\n  error SchemaLib_StaticTypeAfterDynamicType();\n\n  /**\n   * Encode the given schema into a single bytes32\n   */\n  function encode(SchemaType[] memory _schema) internal pure returns (Schema) {\n    if (_schema.length > MAX_TOTAL_FIELDS) revert SchemaLib_InvalidLength(_schema.length);\n    uint256 schema;\n    uint256 totalLength;\n    uint256 dynamicFields;\n\n    // Compute the length of the schema and the number of static fields\n    // and store the schema types in the encoded schema\n    for (uint256 i = 0; i < _schema.length; ) {\n      uint256 staticByteLength = _schema[i].getStaticByteLength();\n\n      if (staticByteLength == 0) {\n        // Increase the dynamic field count if the field is dynamic\n        // (safe because of the initial _schema.length check)\n        unchecked {\n          dynamicFields++;\n        }\n      } else if (dynamicFields > 0) {\n        // Revert if we have seen a dynamic field before, but now we see a static field\n        revert SchemaLib_StaticTypeAfterDynamicType();\n      }\n\n      unchecked {\n        // (safe because 28 (max _schema.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store schema types after the first 4 bytes (which are reserved for length and field numbers)\n        // (safe because of the initial _schema.length check)\n        schema |= uint256(_schema[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Require MAX_DYNAMIC_FIELDS\n    if (dynamicFields > MAX_DYNAMIC_FIELDS) revert SchemaLib_InvalidLength(dynamicFields);\n\n    // Get the static field count\n    uint256 staticFields;\n    unchecked {\n      staticFields = _schema.length - dynamicFields;\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    schema |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    schema |= staticFields << LayoutOffsets.NUM_STATIC_FIELDS;\n    schema |= dynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return Schema.wrap(bytes32(schema));\n  }\n}\n\n/**\n * Instance functions for Schema\n */\nlibrary SchemaInstance {\n  /**\n   * Get the length of the static data for the given schema\n   */\n  function staticDataLength(Schema schema) internal pure returns (uint256) {\n    return uint256(Schema.unwrap(schema)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * Get the type of the data for the given schema at the given index\n   */\n  function atIndex(Schema schema, uint256 index) internal pure returns (SchemaType) {\n    unchecked {\n      return SchemaType(uint8(uint256(schema.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * 8)));\n    }\n  }\n\n  /**\n   * Get the number of static fields for the given schema\n   */\n  function numStaticFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * Get the number of dynamic length fields for the given schema\n   */\n  function numDynamicFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * Get the total number of fields for the given schema\n   */\n  function numFields(Schema schema) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * Check if the given schema is empty\n   */\n  function isEmpty(Schema schema) internal pure returns (bool) {\n    return Schema.unwrap(schema) == bytes32(0);\n  }\n\n  function validate(Schema schema, bool allowEmpty) internal pure {\n    // Schema must not be empty\n    if (!allowEmpty && schema.isEmpty()) revert SchemaLib.SchemaLib_InvalidLength(0);\n\n    // Schema must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = schema.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert SchemaLib.SchemaLib_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = schema.numStaticFields();\n    // Schema must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert SchemaLib.SchemaLib_InvalidLength(_numTotalFields);\n\n    // No static field can be after a dynamic field\n    uint256 countStaticFields;\n    uint256 countDynamicFields;\n    for (uint256 i; i < _numTotalFields; ) {\n      if (schema.atIndex(i).getStaticByteLength() > 0) {\n        // Static field in dynamic part\n        if (i >= _numStaticFields) revert SchemaLib.SchemaLib_StaticTypeAfterDynamicType();\n        unchecked {\n          countStaticFields++;\n        }\n      } else {\n        // Dynamic field in static part\n        if (i < _numStaticFields) revert SchemaLib.SchemaLib_StaticTypeAfterDynamicType();\n        unchecked {\n          countDynamicFields++;\n        }\n      }\n      unchecked {\n        i++;\n      }\n    }\n\n    // Number of static fields must match\n    if (countStaticFields != _numStaticFields) revert SchemaLib.SchemaLib_InvalidLength(countStaticFields);\n\n    // Number of dynamic fields must match\n    if (countDynamicFields != _numDynamicFields) revert SchemaLib.SchemaLib_InvalidLength(countDynamicFields);\n  }\n\n  /**\n   * Unwrap the schema\n   */\n  function unwrap(Schema schema) internal pure returns (bytes32) {\n    return Schema.unwrap(schema);\n  }\n}\n"
    },
    "src/CoreModule/PackedCounter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n// - Last 7 bytes (uint56) are used for the total byte length of the dynamic data\n// - The next 5 byte (uint40) sections are used for the byte length of each field, indexed from right to left\ntype PackedCounter is bytes32;\n\nusing PackedCounterInstance for PackedCounter global;\n\n// Number of bits for the 7-byte accumulator\nuint256 constant ACC_BITS = 7 * 8;\n// Number of bits for the 5-byte sections\nuint256 constant VAL_BITS = 5 * 8;\n// Maximum value of a 5-byte section\nuint256 constant MAX_VAL = type(uint40).max;\n\n/**\n * Static functions for PackedCounter\n * The caller must ensure that the value arguments are <= MAX_VAL\n */\nlibrary PackedCounterLib {\n  function pack(uint256 a) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d + e;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n      packedCounter |= (uint256(e) << (ACC_BITS + VAL_BITS * 4));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n}\n\n/**\n * Instance functions for PackedCounter\n */\nlibrary PackedCounterInstance {\n  error PackedCounter_InvalidLength(uint256 length);\n\n  /**\n   * Decode the accumulated counter\n   * (right-most 7 bytes of packed counter)\n   */\n  function total(PackedCounter packedCounter) internal pure returns (uint256) {\n    return uint56(uint256(PackedCounter.unwrap(packedCounter)));\n  }\n\n  /**\n   * Decode the counter at the given index\n   * (right-to-left, 5 bytes per counter after the right-most 7 bytes)\n   */\n  function atIndex(PackedCounter packedCounter, uint8 index) internal pure returns (uint256) {\n    unchecked {\n      return uint40(uint256(PackedCounter.unwrap(packedCounter) >> (ACC_BITS + VAL_BITS * index)));\n    }\n  }\n\n  /**\n   * Set a counter at the given index, return the new packed counter\n   */\n  function setAtIndex(\n    PackedCounter packedCounter,\n    uint8 index,\n    uint256 newValueAtIndex\n  ) internal pure returns (PackedCounter) {\n    if (newValueAtIndex > MAX_VAL) {\n      revert PackedCounter_InvalidLength(newValueAtIndex);\n    }\n\n    uint256 rawPackedCounter = uint256(PackedCounter.unwrap(packedCounter));\n\n    // Get current lengths (total and at index)\n    uint256 accumulator = total(packedCounter);\n    uint256 currentValueAtIndex = atIndex(packedCounter, index);\n\n    // Compute the difference and update the total value\n    unchecked {\n      if (newValueAtIndex >= currentValueAtIndex) {\n        accumulator += newValueAtIndex - currentValueAtIndex;\n      } else {\n        accumulator -= currentValueAtIndex - newValueAtIndex;\n      }\n    }\n\n    // Set the new accumulated value and value at index\n    // (7 bytes total length, 5 bytes per dynamic field)\n    uint256 offset;\n    unchecked {\n      offset = ACC_BITS + VAL_BITS * index;\n    }\n    // Bitmask with 1s at the 5 bytes that form the value slot at the given index\n    uint256 mask = uint256(type(uint40).max) << offset;\n\n    // First set the last 7 bytes to 0, then set them to the new length\n    rawPackedCounter = (rawPackedCounter & ~uint256(type(uint56).max)) | accumulator;\n\n    // Zero out the value slot at the given index, then set the new value\n    rawPackedCounter = (rawPackedCounter & ~mask) | ((newValueAtIndex << offset) & mask);\n\n    return PackedCounter.wrap(bytes32(rawPackedCounter));\n  }\n\n  /*\n   * Unwrap the packed counter\n   */\n  function unwrap(PackedCounter packedCounter) internal pure returns (bytes32) {\n    return PackedCounter.unwrap(packedCounter);\n  }\n}\n"
    },
    "src/CoreModule/storeResourceTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nbytes2 constant RESOURCE_TABLE = \"tb\";\nbytes2 constant RESOURCE_OFFCHAIN_TABLE = \"ot\";\n"
    },
    "src/CoreModule/IStoreErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { ResourceId } from \"./ResourceId.sol\";\n\ninterface IStoreErrors {\n  // Errors include a stringified version of the tableId for easier debugging if cleartext tableIds are used\n  error Store_TableAlreadyExists(ResourceId tableId, string tableIdString);\n  error Store_TableNotFound(ResourceId tableId, string tableIdString);\n  error Store_InvalidResourceType(bytes2 expected, ResourceId resourceId, string resourceIdString);\n\n  error Store_InvalidDynamicDataLength(uint256 expected, uint256 received);\n  error Store_IndexOutOfBounds(uint256 length, uint256 accessedIndex);\n  error Store_InvalidKeyNamesLength(uint256 expected, uint256 received);\n  error Store_InvalidFieldNamesLength(uint256 expected, uint256 received);\n  error Store_InvalidValueSchemaLength(uint256 expected, uint256 received);\n  error Store_InvalidSplice(uint40 startWithinField, uint40 deleteCount, uint40 fieldLength);\n}\n"
    },
    "src/CoreModule/IStoreData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IStoreRead } from \"./IStoreRead.sol\";\nimport { IStoreWrite } from \"./IStoreWrite.sol\";\n\n/**\n * The IStoreData interface includes methods for reading and writing table values.\n * These methods are frequently invoked during runtime, so it is essential to prioritize\n * optimizing their gas cost\n */\ninterface IStoreData is IStoreRead, IStoreWrite {\n  event HelloStore(bytes32 indexed storeVersion);\n\n  function storeVersion() external view returns (bytes32);\n}\n"
    },
    "src/CoreModule/IStoreRegistration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * The IStoreRegistration interface includes methods for managing table field layouts,\n * metadata, and hooks, which are usually called once in the setup phase of an application,\n * making them less performance critical than the  methods.\n */\ninterface IStoreRegistration {\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] calldata keyNames,\n    string[] calldata fieldNames\n  ) external;\n\n  // Register hook to be called when a record or field is set or deleted\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) external;\n\n  // Unregister a hook for the given tableId\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) external;\n}\n"
    },
    "src/CoreModule/IStoreHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { IERC165, ERC165_INTERFACE_ID } from \"./IERC165_0.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n// ERC-165 Interface ID (see https://eips.ethereum.org/EIPS/eip-165)\nbytes4 constant STORE_HOOK_INTERFACE_ID = IStoreHook.onBeforeSetRecord.selector ^\n  IStoreHook.onAfterSetRecord.selector ^\n  IStoreHook.onBeforeSpliceStaticData.selector ^\n  IStoreHook.onAfterSpliceStaticData.selector ^\n  IStoreHook.onBeforeSpliceDynamicData.selector ^\n  IStoreHook.onAfterSpliceDynamicData.selector ^\n  IStoreHook.onBeforeDeleteRecord.selector ^\n  IStoreHook.onAfterDeleteRecord.selector ^\n  ERC165_INTERFACE_ID;\n\ninterface IStoreHook is IERC165 {\n  error StoreHook_NotImplemented();\n\n  function onBeforeSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  function onAfterSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  function onBeforeSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  function onAfterSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  function onBeforeSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  function onAfterSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  function onBeforeDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n\n  function onAfterDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n}\n"
    },
    "src/CoreModule/version.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nbytes32 constant STORE_VERSION = \"1.0.0-unaudited\";\n"
    },
    "src/CoreModule/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\nimport { Memory } from \"./Memory.sol\";\n\nlibrary Storage {\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, Memory.dataPointer(data), data.length);\n  }\n\n  /**\n   * Stores raw bytes to storage at the given storagePointer and offset (keeping the rest of the word intact)\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 memoryPointer, uint256 length) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, 8)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), mask),\n            // preserve the right part\n            and(sload(storagePointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * Load raw bytes from storage at the given storagePointer, offset, and length\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, length, offset, memoryPointer);\n    return result;\n  }\n\n  /**\n   * Append raw bytes from storage at the given storagePointer, offset, and length to the given memoryPointer\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(wordRemainder);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, 8), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the middle part\n              and(offsetData, mask),\n              // preserve the surrounding parts\n              and(mload(memoryPointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), mask),\n            // preserve the right part\n            and(mload(memoryPointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * Load up to 32 bytes from storage at the given storagePointer and offset.\n   * The return value is left-aligned, the bytes beyond the length are not zeroed out,\n   * and the caller is expected to truncate as needed.\n   * Since fields are tightly packed, they can span more than one slot.\n   * Since the they're max 32 bytes, they can span at most 2 slots.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, 8), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, 8), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}\n"
    },
    "src/CoreModule/index.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */\n\nimport { StoreHooks, StoreHooksTableId } from \"./StoreHooks.sol\";\nimport { Tables, TablesData, TablesTableId } from \"./Tables.sol\";\nimport { ResourceIds, ResourceIdsTableId } from \"./ResourceIds.sol\";\nimport { Hooks } from \"./Hooks.sol\";\n"
    },
    "src/CoreModule/Tables.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import schema type\nimport { SchemaType } from \"./SchemaType.sol\";\n\n// Import store internals\nimport { IStore } from \"./IStore.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { StoreCore } from \"./StoreCore.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { SliceLib } from \"./Slice.sol\";\nimport { EncodeArray } from \"./EncodeArray.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter, PackedCounterLib } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n// Import user types\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { Schema } from \"./Schema.sol\";\n\nResourceId constant _tableId = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(\"store\"), bytes16(\"Tables\")))\n);\nResourceId constant TablesTableId = _tableId;\n\nFieldLayout constant _fieldLayout = FieldLayout.wrap(\n  0x0060030220202000000000000000000000000000000000000000000000000000\n);\n\nstruct TablesData {\n  FieldLayout fieldLayout;\n  Schema keySchema;\n  Schema valueSchema;\n  bytes abiEncodedKeyNames;\n  bytes abiEncodedFieldNames;\n}\n\nlibrary Tables {\n  /** Get the table values' field layout */\n  function getFieldLayout() internal pure returns (FieldLayout) {\n    return _fieldLayout;\n  }\n\n  /** Get the table's key schema */\n  function getKeySchema() internal pure returns (Schema) {\n    SchemaType[] memory _keySchema = new SchemaType[](1);\n    _keySchema[0] = SchemaType.BYTES32;\n\n    return SchemaLib.encode(_keySchema);\n  }\n\n  /** Get the table's value schema */\n  function getValueSchema() internal pure returns (Schema) {\n    SchemaType[] memory _valueSchema = new SchemaType[](5);\n    _valueSchema[0] = SchemaType.BYTES32;\n    _valueSchema[1] = SchemaType.BYTES32;\n    _valueSchema[2] = SchemaType.BYTES32;\n    _valueSchema[3] = SchemaType.BYTES;\n    _valueSchema[4] = SchemaType.BYTES;\n\n    return SchemaLib.encode(_valueSchema);\n  }\n\n  /** Get the table's key names */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"tableId\";\n  }\n\n  /** Get the table's field names */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](5);\n    fieldNames[0] = \"fieldLayout\";\n    fieldNames[1] = \"keySchema\";\n    fieldNames[2] = \"valueSchema\";\n    fieldNames[3] = \"abiEncodedKeyNames\";\n    fieldNames[4] = \"abiEncodedFieldNames\";\n  }\n\n  /** Register the table with its config */\n  function register() internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config */\n  function _register() internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config (using the specified store) */\n  function register(IStore _store) internal {\n    _store.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Get fieldLayout */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout fieldLayout) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return FieldLayout.wrap(bytes32(_blob));\n  }\n\n  /** Get fieldLayout */\n  function _getFieldLayout(ResourceId tableId) internal view returns (FieldLayout fieldLayout) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return FieldLayout.wrap(bytes32(_blob));\n  }\n\n  /** Get fieldLayout (using the specified store) */\n  function getFieldLayout(IStore _store, ResourceId tableId) internal view returns (FieldLayout fieldLayout) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = _store.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return FieldLayout.wrap(bytes32(_blob));\n  }\n\n  /** Set fieldLayout */\n  function setFieldLayout(ResourceId tableId, FieldLayout fieldLayout) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked(FieldLayout.unwrap(fieldLayout)), _fieldLayout);\n  }\n\n  /** Set fieldLayout */\n  function _setFieldLayout(ResourceId tableId, FieldLayout fieldLayout) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked(FieldLayout.unwrap(fieldLayout)), _fieldLayout);\n  }\n\n  /** Set fieldLayout (using the specified store) */\n  function setFieldLayout(IStore _store, ResourceId tableId, FieldLayout fieldLayout) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked(FieldLayout.unwrap(fieldLayout)), _fieldLayout);\n  }\n\n  /** Get keySchema */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /** Get keySchema */\n  function _getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /** Get keySchema (using the specified store) */\n  function getKeySchema(IStore _store, ResourceId tableId) internal view returns (Schema keySchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = _store.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /** Set keySchema */\n  function setKeySchema(ResourceId tableId, Schema keySchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked(Schema.unwrap(keySchema)), _fieldLayout);\n  }\n\n  /** Set keySchema */\n  function _setKeySchema(ResourceId tableId, Schema keySchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked(Schema.unwrap(keySchema)), _fieldLayout);\n  }\n\n  /** Set keySchema (using the specified store) */\n  function setKeySchema(IStore _store, ResourceId tableId, Schema keySchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked(Schema.unwrap(keySchema)), _fieldLayout);\n  }\n\n  /** Get valueSchema */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /** Get valueSchema */\n  function _getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /** Get valueSchema (using the specified store) */\n  function getValueSchema(IStore _store, ResourceId tableId) internal view returns (Schema valueSchema) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes32 _blob = _store.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);\n    return Schema.wrap(bytes32(_blob));\n  }\n\n  /** Set valueSchema */\n  function setValueSchema(ResourceId tableId, Schema valueSchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked(Schema.unwrap(valueSchema)), _fieldLayout);\n  }\n\n  /** Set valueSchema */\n  function _setValueSchema(ResourceId tableId, Schema valueSchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked(Schema.unwrap(valueSchema)), _fieldLayout);\n  }\n\n  /** Set valueSchema (using the specified store) */\n  function setValueSchema(IStore _store, ResourceId tableId, Schema valueSchema) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked(Schema.unwrap(valueSchema)), _fieldLayout);\n  }\n\n  /** Get abiEncodedKeyNames */\n  function getAbiEncodedKeyNames(ResourceId tableId) internal view returns (bytes memory abiEncodedKeyNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (bytes(_blob));\n  }\n\n  /** Get abiEncodedKeyNames */\n  function _getAbiEncodedKeyNames(ResourceId tableId) internal view returns (bytes memory abiEncodedKeyNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (bytes(_blob));\n  }\n\n  /** Get abiEncodedKeyNames (using the specified store) */\n  function getAbiEncodedKeyNames(\n    IStore _store,\n    ResourceId tableId\n  ) internal view returns (bytes memory abiEncodedKeyNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = _store.getDynamicField(_tableId, _keyTuple, 0);\n    return (bytes(_blob));\n  }\n\n  /** Set abiEncodedKeyNames */\n  function setAbiEncodedKeyNames(ResourceId tableId, bytes memory abiEncodedKeyNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, bytes((abiEncodedKeyNames)));\n  }\n\n  /** Set abiEncodedKeyNames */\n  function _setAbiEncodedKeyNames(ResourceId tableId, bytes memory abiEncodedKeyNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, bytes((abiEncodedKeyNames)));\n  }\n\n  /** Set abiEncodedKeyNames (using the specified store) */\n  function setAbiEncodedKeyNames(IStore _store, ResourceId tableId, bytes memory abiEncodedKeyNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setDynamicField(_tableId, _keyTuple, 0, bytes((abiEncodedKeyNames)));\n  }\n\n  /** Get the length of abiEncodedKeyNames */\n  function lengthAbiEncodedKeyNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /** Get the length of abiEncodedKeyNames */\n  function _lengthAbiEncodedKeyNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /** Get the length of abiEncodedKeyNames (using the specified store) */\n  function lengthAbiEncodedKeyNames(IStore _store, ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = _store.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /**\n   * Get an item of abiEncodedKeyNames\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemAbiEncodedKeyNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * Get an item of abiEncodedKeyNames\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function _getItemAbiEncodedKeyNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * Get an item of abiEncodedKeyNames (using the specified store)\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemAbiEncodedKeyNames(\n    IStore _store,\n    ResourceId tableId,\n    uint256 _index\n  ) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = _store.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /** Push a slice to abiEncodedKeyNames */\n  function pushAbiEncodedKeyNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, bytes((_slice)));\n  }\n\n  /** Push a slice to abiEncodedKeyNames */\n  function _pushAbiEncodedKeyNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, bytes((_slice)));\n  }\n\n  /** Push a slice to abiEncodedKeyNames (using the specified store) */\n  function pushAbiEncodedKeyNames(IStore _store, ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.pushToDynamicField(_tableId, _keyTuple, 0, bytes((_slice)));\n  }\n\n  /** Pop a slice from abiEncodedKeyNames */\n  function popAbiEncodedKeyNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 1);\n  }\n\n  /** Pop a slice from abiEncodedKeyNames */\n  function _popAbiEncodedKeyNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 1);\n  }\n\n  /** Pop a slice from abiEncodedKeyNames (using the specified store) */\n  function popAbiEncodedKeyNames(IStore _store, ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.popFromDynamicField(_tableId, _keyTuple, 0, 1);\n  }\n\n  /**\n   * Update a slice of abiEncodedKeyNames at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateAbiEncodedKeyNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update a slice of abiEncodedKeyNames at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function _updateAbiEncodedKeyNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update a slice of abiEncodedKeyNames (using the specified store) at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateAbiEncodedKeyNames(IStore _store, ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      _store.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /** Get abiEncodedFieldNames */\n  function getAbiEncodedFieldNames(ResourceId tableId) internal view returns (bytes memory abiEncodedFieldNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 1);\n    return (bytes(_blob));\n  }\n\n  /** Get abiEncodedFieldNames */\n  function _getAbiEncodedFieldNames(ResourceId tableId) internal view returns (bytes memory abiEncodedFieldNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 1);\n    return (bytes(_blob));\n  }\n\n  /** Get abiEncodedFieldNames (using the specified store) */\n  function getAbiEncodedFieldNames(\n    IStore _store,\n    ResourceId tableId\n  ) internal view returns (bytes memory abiEncodedFieldNames) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = _store.getDynamicField(_tableId, _keyTuple, 1);\n    return (bytes(_blob));\n  }\n\n  /** Set abiEncodedFieldNames */\n  function setAbiEncodedFieldNames(ResourceId tableId, bytes memory abiEncodedFieldNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 1, bytes((abiEncodedFieldNames)));\n  }\n\n  /** Set abiEncodedFieldNames */\n  function _setAbiEncodedFieldNames(ResourceId tableId, bytes memory abiEncodedFieldNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 1, bytes((abiEncodedFieldNames)));\n  }\n\n  /** Set abiEncodedFieldNames (using the specified store) */\n  function setAbiEncodedFieldNames(IStore _store, ResourceId tableId, bytes memory abiEncodedFieldNames) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setDynamicField(_tableId, _keyTuple, 1, bytes((abiEncodedFieldNames)));\n  }\n\n  /** Get the length of abiEncodedFieldNames */\n  function lengthAbiEncodedFieldNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 1);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /** Get the length of abiEncodedFieldNames */\n  function _lengthAbiEncodedFieldNames(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 1);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /** Get the length of abiEncodedFieldNames (using the specified store) */\n  function lengthAbiEncodedFieldNames(IStore _store, ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = _store.getDynamicFieldLength(_tableId, _keyTuple, 1);\n    unchecked {\n      return _byteLength / 1;\n    }\n  }\n\n  /**\n   * Get an item of abiEncodedFieldNames\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemAbiEncodedFieldNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * Get an item of abiEncodedFieldNames\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function _getItemAbiEncodedFieldNames(ResourceId tableId, uint256 _index) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /**\n   * Get an item of abiEncodedFieldNames (using the specified store)\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemAbiEncodedFieldNames(\n    IStore _store,\n    ResourceId tableId,\n    uint256 _index\n  ) internal view returns (bytes memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = _store.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 1, (_index + 1) * 1);\n      return (bytes(_blob));\n    }\n  }\n\n  /** Push a slice to abiEncodedFieldNames */\n  function pushAbiEncodedFieldNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 1, bytes((_slice)));\n  }\n\n  /** Push a slice to abiEncodedFieldNames */\n  function _pushAbiEncodedFieldNames(ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 1, bytes((_slice)));\n  }\n\n  /** Push a slice to abiEncodedFieldNames (using the specified store) */\n  function pushAbiEncodedFieldNames(IStore _store, ResourceId tableId, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.pushToDynamicField(_tableId, _keyTuple, 1, bytes((_slice)));\n  }\n\n  /** Pop a slice from abiEncodedFieldNames */\n  function popAbiEncodedFieldNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 1, 1);\n  }\n\n  /** Pop a slice from abiEncodedFieldNames */\n  function _popAbiEncodedFieldNames(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 1, 1);\n  }\n\n  /** Pop a slice from abiEncodedFieldNames (using the specified store) */\n  function popAbiEncodedFieldNames(IStore _store, ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.popFromDynamicField(_tableId, _keyTuple, 1, 1);\n  }\n\n  /**\n   * Update a slice of abiEncodedFieldNames at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateAbiEncodedFieldNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update a slice of abiEncodedFieldNames at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function _updateAbiEncodedFieldNames(ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update a slice of abiEncodedFieldNames (using the specified store) at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateAbiEncodedFieldNames(IStore _store, ResourceId tableId, uint256 _index, bytes memory _slice) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = bytes((_slice));\n      _store.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 1), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /** Get the full data */\n  function get(ResourceId tableId) internal view returns (TablesData memory _table) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    (bytes memory _staticData, PackedCounter _encodedLengths, bytes memory _dynamicData) = StoreSwitch.getRecord(\n      _tableId,\n      _keyTuple,\n      _fieldLayout\n    );\n    return decode(_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Get the full data */\n  function _get(ResourceId tableId) internal view returns (TablesData memory _table) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    (bytes memory _staticData, PackedCounter _encodedLengths, bytes memory _dynamicData) = StoreCore.getRecord(\n      _tableId,\n      _keyTuple,\n      _fieldLayout\n    );\n    return decode(_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Get the full data (using the specified store) */\n  function get(IStore _store, ResourceId tableId) internal view returns (TablesData memory _table) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    (bytes memory _staticData, PackedCounter _encodedLengths, bytes memory _dynamicData) = _store.getRecord(\n      _tableId,\n      _keyTuple,\n      _fieldLayout\n    );\n    return decode(_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Set the full data using individual values */\n  function set(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal {\n    bytes memory _staticData = encodeStatic(fieldLayout, keySchema, valueSchema);\n\n    PackedCounter _encodedLengths = encodeLengths(abiEncodedKeyNames, abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(abiEncodedKeyNames, abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Set the full data using individual values */\n  function _set(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal {\n    bytes memory _staticData = encodeStatic(fieldLayout, keySchema, valueSchema);\n\n    PackedCounter _encodedLengths = encodeLengths(abiEncodedKeyNames, abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(abiEncodedKeyNames, abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);\n  }\n\n  /** Set the full data using individual values (using the specified store) */\n  function set(\n    IStore _store,\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal {\n    bytes memory _staticData = encodeStatic(fieldLayout, keySchema, valueSchema);\n\n    PackedCounter _encodedLengths = encodeLengths(abiEncodedKeyNames, abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(abiEncodedKeyNames, abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Set the full data using the data struct */\n  function set(ResourceId tableId, TablesData memory _table) internal {\n    bytes memory _staticData = encodeStatic(_table.fieldLayout, _table.keySchema, _table.valueSchema);\n\n    PackedCounter _encodedLengths = encodeLengths(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Set the full data using the data struct */\n  function _set(ResourceId tableId, TablesData memory _table) internal {\n    bytes memory _staticData = encodeStatic(_table.fieldLayout, _table.keySchema, _table.valueSchema);\n\n    PackedCounter _encodedLengths = encodeLengths(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);\n  }\n\n  /** Set the full data using the data struct (using the specified store) */\n  function set(IStore _store, ResourceId tableId, TablesData memory _table) internal {\n    bytes memory _staticData = encodeStatic(_table.fieldLayout, _table.keySchema, _table.valueSchema);\n\n    PackedCounter _encodedLengths = encodeLengths(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(_table.abiEncodedKeyNames, _table.abiEncodedFieldNames);\n\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);\n  }\n\n  /**\n   * Decode the tightly packed blob of static data using this table's field layout\n   * Undefined behaviour for invalid blobs\n   */\n  function decodeStatic(\n    bytes memory _blob\n  ) internal pure returns (FieldLayout fieldLayout, Schema keySchema, Schema valueSchema) {\n    fieldLayout = FieldLayout.wrap(Bytes.slice32(_blob, 0));\n\n    keySchema = Schema.wrap(Bytes.slice32(_blob, 32));\n\n    valueSchema = Schema.wrap(Bytes.slice32(_blob, 64));\n  }\n\n  /**\n   * Decode the tightly packed blob of static data using this table's field layout\n   * Undefined behaviour for invalid blobs\n   */\n  function decodeDynamic(\n    PackedCounter _encodedLengths,\n    bytes memory _blob\n  ) internal pure returns (bytes memory abiEncodedKeyNames, bytes memory abiEncodedFieldNames) {\n    uint256 _start;\n    uint256 _end;\n    unchecked {\n      _end = _encodedLengths.atIndex(0);\n    }\n    abiEncodedKeyNames = (bytes(SliceLib.getSubslice(_blob, _start, _end).toBytes()));\n\n    _start = _end;\n    unchecked {\n      _end += _encodedLengths.atIndex(1);\n    }\n    abiEncodedFieldNames = (bytes(SliceLib.getSubslice(_blob, _start, _end).toBytes()));\n  }\n\n  /**\n   * Decode the tightly packed blob using this table's field layout.\n   * Undefined behaviour for invalid blobs.\n   */\n  function decode(\n    bytes memory _staticData,\n    PackedCounter _encodedLengths,\n    bytes memory _dynamicData\n  ) internal pure returns (TablesData memory _table) {\n    (_table.fieldLayout, _table.keySchema, _table.valueSchema) = decodeStatic(_staticData);\n\n    (_table.abiEncodedKeyNames, _table.abiEncodedFieldNames) = decodeDynamic(_encodedLengths, _dynamicData);\n  }\n\n  /** Delete all data for given keys */\n  function deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Delete all data for given keys */\n  function _deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /** Delete all data for given keys (using the specified store) */\n  function deleteRecord(IStore _store, ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Tightly pack static data using this table's schema */\n  function encodeStatic(\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(fieldLayout, keySchema, valueSchema);\n  }\n\n  /** Tightly pack dynamic data using this table's schema */\n  function encodeLengths(\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal pure returns (PackedCounter _encodedLengths) {\n    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits\n    unchecked {\n      _encodedLengths = PackedCounterLib.pack(bytes(abiEncodedKeyNames).length, bytes(abiEncodedFieldNames).length);\n    }\n  }\n\n  /** Tightly pack dynamic data using this table's schema */\n  function encodeDynamic(\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(bytes((abiEncodedKeyNames)), bytes((abiEncodedFieldNames)));\n  }\n\n  /** Tightly pack full data using this table's field layout */\n  function encode(\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    bytes memory abiEncodedKeyNames,\n    bytes memory abiEncodedFieldNames\n  ) internal pure returns (bytes memory, PackedCounter, bytes memory) {\n    bytes memory _staticData = encodeStatic(fieldLayout, keySchema, valueSchema);\n\n    PackedCounter _encodedLengths = encodeLengths(abiEncodedKeyNames, abiEncodedFieldNames);\n    bytes memory _dynamicData = encodeDynamic(abiEncodedKeyNames, abiEncodedFieldNames);\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Encode keys as a bytes32 array using this table's field layout */\n  function encodeKeyTuple(ResourceId tableId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    return _keyTuple;\n  }\n}\n"
    },
    "src/CoreModule/storeHookTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nuint8 constant BEFORE_SET_RECORD = 1 << 0;\nuint8 constant AFTER_SET_RECORD = 1 << 1;\nuint8 constant BEFORE_SPLICE_STATIC_DATA = 1 << 2;\nuint8 constant AFTER_SPLICE_STATIC_DATA = 1 << 3;\nuint8 constant BEFORE_SPLICE_DYNAMIC_DATA = 1 << 4;\nuint8 constant AFTER_SPLICE_DYNAMIC_DATA = 1 << 5;\nuint8 constant BEFORE_DELETE_RECORD = 1 << 6;\nuint8 constant AFTER_DELETE_RECORD = 1 << 7;\n\nuint8 constant ALL = BEFORE_SET_RECORD |\n  AFTER_SET_RECORD |\n  BEFORE_SPLICE_STATIC_DATA |\n  AFTER_SPLICE_STATIC_DATA |\n  BEFORE_SPLICE_DYNAMIC_DATA |\n  AFTER_SPLICE_DYNAMIC_DATA |\n  BEFORE_DELETE_RECORD |\n  AFTER_DELETE_RECORD;\n\nuint8 constant BEFORE_ALL = BEFORE_SET_RECORD |\n  BEFORE_SPLICE_STATIC_DATA |\n  BEFORE_SPLICE_DYNAMIC_DATA |\n  BEFORE_DELETE_RECORD;\n\nuint8 constant AFTER_ALL = AFTER_SET_RECORD |\n  AFTER_SPLICE_STATIC_DATA |\n  AFTER_SPLICE_DYNAMIC_DATA |\n  AFTER_DELETE_RECORD;\n"
    },
    "src/CoreModule/leftMask.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/**\n * Adapted from https://github.com/dk1a/solidity-stringutils/blob/main/src/utils/mem.sol#L149-L167\n * @dev Left-aligned byte mask (e.g. for partial mload/mstore).\n * For byteLength >= 32 returns type(uint256).max\n *\n * length 0:   0x000000...000000\n * length 1:   0xff0000...000000\n * length 2:   0xffff00...000000\n * ...\n * length 30:  0xffffff...ff0000\n * length 31:  0xffffff...ffff00\n * length 32+: 0xffffff...ffffff\n */\nfunction leftMask(uint256 byteLength) pure returns (uint256) {\n  unchecked {\n    return ~(type(uint256).max >> (byteLength * 8));\n  }\n}\n"
    },
    "src/CoreModule/DecodeSlice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */\nimport { TightCoder } from \"./TightCoder.sol\";\nimport { Slice } from \"./Slice.sol\";\n\nlibrary DecodeSlice {\n  function decodeArray_uint8(Slice _input) internal pure returns (uint8[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 248);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint16(Slice _input) internal pure returns (uint16[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 2, 240);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint24(Slice _input) internal pure returns (uint24[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 3, 232);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint32(Slice _input) internal pure returns (uint32[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 4, 224);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint40(Slice _input) internal pure returns (uint40[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 5, 216);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint48(Slice _input) internal pure returns (uint48[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 6, 208);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint56(Slice _input) internal pure returns (uint56[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 7, 200);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint64(Slice _input) internal pure returns (uint64[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 8, 192);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint72(Slice _input) internal pure returns (uint72[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 9, 184);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint80(Slice _input) internal pure returns (uint80[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 10, 176);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint88(Slice _input) internal pure returns (uint88[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 11, 168);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint96(Slice _input) internal pure returns (uint96[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 12, 160);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint104(Slice _input) internal pure returns (uint104[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 13, 152);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint112(Slice _input) internal pure returns (uint112[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 14, 144);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint120(Slice _input) internal pure returns (uint120[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 15, 136);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint128(Slice _input) internal pure returns (uint128[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 16, 128);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint136(Slice _input) internal pure returns (uint136[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 17, 120);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint144(Slice _input) internal pure returns (uint144[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 18, 112);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint152(Slice _input) internal pure returns (uint152[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 19, 104);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint160(Slice _input) internal pure returns (uint160[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 96);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint168(Slice _input) internal pure returns (uint168[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 21, 88);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint176(Slice _input) internal pure returns (uint176[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 22, 80);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint184(Slice _input) internal pure returns (uint184[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 23, 72);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint192(Slice _input) internal pure returns (uint192[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 24, 64);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint200(Slice _input) internal pure returns (uint200[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 25, 56);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint208(Slice _input) internal pure returns (uint208[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 26, 48);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint216(Slice _input) internal pure returns (uint216[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 27, 40);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint224(Slice _input) internal pure returns (uint224[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 28, 32);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint232(Slice _input) internal pure returns (uint232[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 29, 24);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint240(Slice _input) internal pure returns (uint240[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 30, 16);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint248(Slice _input) internal pure returns (uint248[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 31, 8);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_uint256(Slice _input) internal pure returns (uint256[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 32, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int8(Slice _input) internal pure returns (int8[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 248);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int16(Slice _input) internal pure returns (int16[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 2, 240);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int24(Slice _input) internal pure returns (int24[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 3, 232);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int32(Slice _input) internal pure returns (int32[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 4, 224);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int40(Slice _input) internal pure returns (int40[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 5, 216);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int48(Slice _input) internal pure returns (int48[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 6, 208);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int56(Slice _input) internal pure returns (int56[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 7, 200);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int64(Slice _input) internal pure returns (int64[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 8, 192);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int72(Slice _input) internal pure returns (int72[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 9, 184);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int80(Slice _input) internal pure returns (int80[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 10, 176);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int88(Slice _input) internal pure returns (int88[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 11, 168);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int96(Slice _input) internal pure returns (int96[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 12, 160);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int104(Slice _input) internal pure returns (int104[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 13, 152);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int112(Slice _input) internal pure returns (int112[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 14, 144);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int120(Slice _input) internal pure returns (int120[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 15, 136);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int128(Slice _input) internal pure returns (int128[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 16, 128);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int136(Slice _input) internal pure returns (int136[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 17, 120);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int144(Slice _input) internal pure returns (int144[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 18, 112);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int152(Slice _input) internal pure returns (int152[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 19, 104);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int160(Slice _input) internal pure returns (int160[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 96);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int168(Slice _input) internal pure returns (int168[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 21, 88);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int176(Slice _input) internal pure returns (int176[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 22, 80);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int184(Slice _input) internal pure returns (int184[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 23, 72);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int192(Slice _input) internal pure returns (int192[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 24, 64);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int200(Slice _input) internal pure returns (int200[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 25, 56);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int208(Slice _input) internal pure returns (int208[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 26, 48);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int216(Slice _input) internal pure returns (int216[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 27, 40);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int224(Slice _input) internal pure returns (int224[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 28, 32);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int232(Slice _input) internal pure returns (int232[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 29, 24);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int240(Slice _input) internal pure returns (int240[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 30, 16);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int248(Slice _input) internal pure returns (int248[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 31, 8);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_int256(Slice _input) internal pure returns (int256[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 32, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes1(Slice _input) internal pure returns (bytes1[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes2(Slice _input) internal pure returns (bytes2[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 2, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes3(Slice _input) internal pure returns (bytes3[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 3, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes4(Slice _input) internal pure returns (bytes4[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 4, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes5(Slice _input) internal pure returns (bytes5[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 5, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes6(Slice _input) internal pure returns (bytes6[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 6, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes7(Slice _input) internal pure returns (bytes7[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 7, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes8(Slice _input) internal pure returns (bytes8[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 8, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes9(Slice _input) internal pure returns (bytes9[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 9, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes10(Slice _input) internal pure returns (bytes10[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 10, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes11(Slice _input) internal pure returns (bytes11[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 11, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes12(Slice _input) internal pure returns (bytes12[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 12, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes13(Slice _input) internal pure returns (bytes13[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 13, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes14(Slice _input) internal pure returns (bytes14[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 14, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes15(Slice _input) internal pure returns (bytes15[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 15, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes16(Slice _input) internal pure returns (bytes16[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 16, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes17(Slice _input) internal pure returns (bytes17[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 17, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes18(Slice _input) internal pure returns (bytes18[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 18, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes19(Slice _input) internal pure returns (bytes19[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 19, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes20(Slice _input) internal pure returns (bytes20[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes21(Slice _input) internal pure returns (bytes21[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 21, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes22(Slice _input) internal pure returns (bytes22[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 22, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes23(Slice _input) internal pure returns (bytes23[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 23, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes24(Slice _input) internal pure returns (bytes24[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 24, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes25(Slice _input) internal pure returns (bytes25[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 25, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes26(Slice _input) internal pure returns (bytes26[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 26, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes27(Slice _input) internal pure returns (bytes27[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 27, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes28(Slice _input) internal pure returns (bytes28[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 28, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes29(Slice _input) internal pure returns (bytes29[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 29, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes30(Slice _input) internal pure returns (bytes30[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 30, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes31(Slice _input) internal pure returns (bytes31[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 31, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bytes32(Slice _input) internal pure returns (bytes32[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 32, 0);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_bool(Slice _input) internal pure returns (bool[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 1, 248);\n    assembly {\n      _output := _genericArray\n    }\n  }\n\n  function decodeArray_address(Slice _input) internal pure returns (address[] memory _output) {\n    bytes32[] memory _genericArray = TightCoder.decode(_input, 20, 96);\n    assembly {\n      _output := _genericArray\n    }\n  }\n}\n"
    },
    "src/CoreModule/TightCoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Slice, SliceLib } from \"./Slice.sol\";\n\n/**\n * Low-level generic implementation of tight encoding for arrays, used by codegen.\n * This is the same as solidity's internal tight encoding for array data in storage.\n */\nlibrary TightCoder {\n  /**\n   * Copies the array to a new bytes array, tightly packing it.\n   * elementSize is in bytes, leftPaddingBits is in bits.\n   * elementSize and leftPaddingBits must be correctly provided by the caller based on the array's element type.\n   * @return data a tightly packed array\n   */\n  function encode(\n    bytes32[] memory array,\n    uint256 elementSize,\n    uint256 leftPaddingBits\n  ) internal pure returns (bytes memory data) {\n    uint256 arrayLength = array.length;\n    uint256 packedLength = array.length * elementSize;\n\n    // Manual memory allocation is cheaper and removes the issue of memory corruption at the tail\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      data := mload(0x40)\n      let packedPointer := add(data, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(packedPointer, packedLength)))\n      // Store length\n      mstore(data, packedLength)\n\n      for {\n        let i := 0\n        // Skip array length\n        let arrayPointer := add(array, 0x20)\n      } lt(i, arrayLength) {\n        // Loop until we reach the end of the array\n        i := add(i, 1)\n        // Increment array pointer by one word\n        arrayPointer := add(arrayPointer, 0x20)\n        // Increment packed pointer by one element size\n        packedPointer := add(packedPointer, elementSize)\n      } {\n        // Pack one array element\n        mstore(packedPointer, shl(leftPaddingBits, mload(arrayPointer)))\n      }\n    }\n  }\n\n  /**\n   * Unpacks the slice to a new memory location and lays it out like a memory array.\n   * elementSize is in bytes, leftPaddingBits is in bits.\n   * elementSize and leftPaddingBits must be correctly provided by the caller based on the array's element type.\n   * @return array a generic array, needs to be casted to the expected type using assembly\n   */\n  function decode(\n    Slice packedSlice,\n    uint256 elementSize,\n    uint256 leftPaddingBits\n  ) internal pure returns (bytes32[] memory array) {\n    uint256 packedPointer = packedSlice.pointer();\n    uint256 packedLength = packedSlice.length();\n    // Array length (number of elements)\n    uint256 arrayLength;\n    unchecked {\n      arrayLength = packedLength / elementSize;\n    }\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Allocate memory\n      array := mload(0x40)\n      let arrayPointer := add(array, 0x20)\n      mstore(0x40, add(arrayPointer, mul(arrayLength, 32)))\n      // Store length\n      mstore(array, arrayLength)\n\n      for {\n        let i := 0\n      } lt(i, arrayLength) {\n        // Loop until we reach the end of the array\n        i := add(i, 1)\n        // Increment array pointer by one word\n        arrayPointer := add(arrayPointer, 0x20)\n        // Increment packed pointer by one element size\n        packedPointer := add(packedPointer, elementSize)\n      } {\n        // Unpack one array element\n        mstore(arrayPointer, shr(leftPaddingBits, mload(packedPointer)))\n      }\n    }\n  }\n}\n"
    },
    "src/CoreModule/constants_1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Shared constants */\n\n// Total byte length of an EVM word\nuint256 constant WORD_SIZE = 32;\n// Index of the last byte in an EVM word\nuint256 constant WORD_LAST_INDEX = 31;\n// Conversion for bit shifting\nuint256 constant BYTE_TO_BITS = 8;\n\n// Schema's capacity\nuint256 constant MAX_TOTAL_FIELDS = 28;\n// FieldLayout's capacity\nuint256 constant MAX_STATIC_FIELDS = 28;\n// PackedCounter's capacity\nuint256 constant MAX_DYNAMIC_FIELDS = 5;\n\n// FieldLayout and Schema have the same offsets for metadata\nlibrary LayoutOffsets {\n  uint256 internal constant TOTAL_LENGTH = (WORD_SIZE - 2) * BYTE_TO_BITS;\n  uint256 internal constant NUM_STATIC_FIELDS = (WORD_SIZE - 2 - 1) * BYTE_TO_BITS;\n  uint256 internal constant NUM_DYNAMIC_FIELDS = (WORD_SIZE - 2 - 1 - 1) * BYTE_TO_BITS;\n}\n"
    },
    "src/CoreModule/IStoreRead.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\ninterface IStoreRead {\n  function getFieldLayout(ResourceId tableId) external view returns (FieldLayout fieldLayout);\n\n  function getValueSchema(ResourceId tableId) external view returns (Schema valueSchema);\n\n  function getKeySchema(ResourceId tableId) external view returns (Schema keySchema);\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given tableId and key tuple, loading the field layout from storage\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple\n  ) external view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData);\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given tableId and key tuple, with the given field layout\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    FieldLayout fieldLayout\n  ) external view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData);\n\n  /**\n   * Get a single field from the given tableId and key tuple, loading the field layout from storage\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex\n  ) external view returns (bytes memory data);\n\n  /**\n   * Get a single field from the given tableId and key tuple, with the given field layout\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (bytes memory data);\n\n  /**\n   * Get a single static field from the given tableId and key tuple, with the given value field layout.\n   * Note: the field value is left-aligned in the returned bytes32, the rest of the word is not zeroed out.\n   * Consumers are expected to truncate the returned value as needed.\n   */\n  function getStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (bytes32);\n\n  /**\n   * Get a single dynamic field from the given tableId and key tuple at the given dynamic field index.\n   * (Dynamic field index = field index - number of static fields)\n   */\n  function getDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) external view returns (bytes memory);\n\n  /**\n   * Get the byte length of a single field from the given tableId and key tuple, loading the field layout from storage\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) external view returns (uint256);\n\n  /**\n   * Get the byte length of a single field from the given tableId and key tuple, with the given value field layout\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (uint256);\n\n  /**\n   * Get the byte length of a single dynamic field from the given tableId and key tuple\n   */\n  function getDynamicFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) external view returns (uint256);\n\n  /**\n   * Get a byte slice (including start, excluding end) of a single dynamic field from the given tableId and key tuple, with the given value field layout.\n   * The slice is unchecked and will return invalid data if `start`:`end` overflow.\n   */\n  function getDynamicFieldSlice(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 start,\n    uint256 end\n  ) external view returns (bytes memory data);\n}\n"
    },
    "src/CoreModule/IStoreWrite.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IStoreEvents } from \"./IStoreEvents.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\ninterface IStoreWrite is IStoreEvents {\n  // Set full record (including full dynamic data)\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    bytes calldata staticData,\n    PackedCounter encodedLengths,\n    bytes calldata dynamicData\n  ) external;\n\n  // Splice data in the static part of the record\n  function spliceStaticData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint48 start,\n    bytes calldata data\n  ) external;\n\n  // Splice data in the dynamic part of the record\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes calldata data\n  ) external;\n\n  // Set partial data at field index\n  function setField(ResourceId tableId, bytes32[] calldata keyTuple, uint8 fieldIndex, bytes calldata data) external;\n\n  // Set partial data at field index\n  function setField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) external;\n\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) external;\n\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata data\n  ) external;\n\n  // Push encoded items to the dynamic field at field index\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata dataToPush\n  ) external;\n\n  // Pop byte length from the dynamic field at field index\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) external;\n\n  // Set full record (including full dynamic data)\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) external;\n}\n"
    },
    "src/CoreModule/IERC165_0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nbytes4 constant ERC165_INTERFACE_ID = IERC165.supportsInterface.selector;\n\n// See https://eips.ethereum.org/EIPS/eip-165\ninterface IERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/CoreModule/StoreHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import schema type\nimport { SchemaType } from \"./SchemaType.sol\";\n\n// Import store internals\nimport { IStore } from \"./IStore.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { StoreCore } from \"./StoreCore.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { SliceLib } from \"./Slice.sol\";\nimport { EncodeArray } from \"./EncodeArray.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter, PackedCounterLib } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n// Import user types\nimport { ResourceId } from \"./ResourceId.sol\";\n\nResourceId constant _tableId = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(\"store\"), bytes16(\"StoreHooks\")))\n);\nResourceId constant StoreHooksTableId = _tableId;\n\nFieldLayout constant _fieldLayout = FieldLayout.wrap(\n  0x0000000100000000000000000000000000000000000000000000000000000000\n);\n\nlibrary StoreHooks {\n  /** Get the table values' field layout */\n  function getFieldLayout() internal pure returns (FieldLayout) {\n    return _fieldLayout;\n  }\n\n  /** Get the table's key schema */\n  function getKeySchema() internal pure returns (Schema) {\n    SchemaType[] memory _keySchema = new SchemaType[](1);\n    _keySchema[0] = SchemaType.BYTES32;\n\n    return SchemaLib.encode(_keySchema);\n  }\n\n  /** Get the table's value schema */\n  function getValueSchema() internal pure returns (Schema) {\n    SchemaType[] memory _valueSchema = new SchemaType[](1);\n    _valueSchema[0] = SchemaType.BYTES21_ARRAY;\n\n    return SchemaLib.encode(_valueSchema);\n  }\n\n  /** Get the table's key names */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"tableId\";\n  }\n\n  /** Get the table's field names */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](1);\n    fieldNames[0] = \"hooks\";\n  }\n\n  /** Register the table with its config */\n  function register() internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config */\n  function _register() internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config (using the specified store) */\n  function register(IStore _store) internal {\n    _store.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Get hooks */\n  function getHooks(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks */\n  function _getHooks(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks (using the specified store) */\n  function getHooks(IStore _store, ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = _store.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks */\n  function get(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks */\n  function _get(ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Get hooks (using the specified store) */\n  function get(IStore _store, ResourceId tableId) internal view returns (bytes21[] memory hooks) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    bytes memory _blob = _store.getDynamicField(_tableId, _keyTuple, 0);\n    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes21());\n  }\n\n  /** Set hooks */\n  function setHooks(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks */\n  function _setHooks(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks (using the specified store) */\n  function setHooks(IStore _store, ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks */\n  function set(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks */\n  function _set(ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Set hooks (using the specified store) */\n  function set(IStore _store, ResourceId tableId, bytes21[] memory hooks) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((hooks)));\n  }\n\n  /** Get the length of hooks */\n  function lengthHooks(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks */\n  function _lengthHooks(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks (using the specified store) */\n  function lengthHooks(IStore _store, ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = _store.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks */\n  function length(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks */\n  function _length(ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /** Get the length of hooks (using the specified store) */\n  function length(IStore _store, ResourceId tableId) internal view returns (uint256) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    uint256 _byteLength = _store.getDynamicFieldLength(_tableId, _keyTuple, 0);\n    unchecked {\n      return _byteLength / 21;\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemHooks(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function _getItemHooks(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks (using the specified store)\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItemHooks(IStore _store, ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = _store.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItem(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function _getItem(ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /**\n   * Get an item of hooks (using the specified store)\n   * (unchecked, returns invalid data if index overflows)\n   */\n  function getItem(IStore _store, ResourceId tableId, uint256 _index) internal view returns (bytes21) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _blob = _store.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 21, (_index + 1) * 21);\n      return (bytes21(_blob));\n    }\n  }\n\n  /** Push an element to hooks */\n  function pushHooks(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks */\n  function _pushHooks(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks (using the specified store) */\n  function pushHooks(IStore _store, ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks */\n  function push(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks */\n  function _push(ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Push an element to hooks (using the specified store) */\n  function push(IStore _store, ResourceId tableId, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));\n  }\n\n  /** Pop an element from hooks */\n  function popHooks(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks */\n  function _popHooks(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks (using the specified store) */\n  function popHooks(IStore _store, ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks */\n  function pop(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks */\n  function _pop(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /** Pop an element from hooks (using the specified store) */\n  function pop(IStore _store, ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.popFromDynamicField(_tableId, _keyTuple, 0, 21);\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateHooks(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function _updateHooks(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks (using the specified store) at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function updateHooks(IStore _store, ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      _store.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function update(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function _update(ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /**\n   * Update an element of hooks (using the specified store) at `_index`\n   * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n   */\n  function update(IStore _store, ResourceId tableId, uint256 _index, bytes21 _element) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    unchecked {\n      bytes memory _encoded = abi.encodePacked((_element));\n      _store.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 21), uint40(_encoded.length), _encoded);\n    }\n  }\n\n  /** Delete all data for given keys */\n  function deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Delete all data for given keys */\n  function _deleteRecord(ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /** Delete all data for given keys (using the specified store) */\n  function deleteRecord(IStore _store, ResourceId tableId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    _store.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Tightly pack dynamic data using this table's schema */\n  function encodeLengths(bytes21[] memory hooks) internal pure returns (PackedCounter _encodedLengths) {\n    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits\n    unchecked {\n      _encodedLengths = PackedCounterLib.pack(hooks.length * 21);\n    }\n  }\n\n  /** Tightly pack dynamic data using this table's schema */\n  function encodeDynamic(bytes21[] memory hooks) internal pure returns (bytes memory) {\n    return abi.encodePacked(EncodeArray.encode((hooks)));\n  }\n\n  /** Tightly pack full data using this table's field layout */\n  function encode(bytes21[] memory hooks) internal pure returns (bytes memory, PackedCounter, bytes memory) {\n    bytes memory _staticData;\n    PackedCounter _encodedLengths = encodeLengths(hooks);\n    bytes memory _dynamicData = encodeDynamic(hooks);\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Encode keys as a bytes32 array using this table's field layout */\n  function encodeKeyTuple(ResourceId tableId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(tableId);\n\n    return _keyTuple;\n  }\n}\n"
    },
    "src/CoreModule/ResourceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */\n\n// Import schema type\nimport { SchemaType } from \"./SchemaType.sol\";\n\n// Import store internals\nimport { IStore } from \"./IStore.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { StoreCore } from \"./StoreCore.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { SliceLib } from \"./Slice.sol\";\nimport { EncodeArray } from \"./EncodeArray.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter, PackedCounterLib } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n// Import user types\nimport { ResourceId } from \"./ResourceId.sol\";\n\nResourceId constant _tableId = ResourceId.wrap(\n  bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(\"store\"), bytes16(\"ResourceIds\")))\n);\nResourceId constant ResourceIdsTableId = _tableId;\n\nFieldLayout constant _fieldLayout = FieldLayout.wrap(\n  0x0001010001000000000000000000000000000000000000000000000000000000\n);\n\nlibrary ResourceIds {\n  /** Get the table values' field layout */\n  function getFieldLayout() internal pure returns (FieldLayout) {\n    return _fieldLayout;\n  }\n\n  /** Get the table's key schema */\n  function getKeySchema() internal pure returns (Schema) {\n    SchemaType[] memory _keySchema = new SchemaType[](1);\n    _keySchema[0] = SchemaType.BYTES32;\n\n    return SchemaLib.encode(_keySchema);\n  }\n\n  /** Get the table's value schema */\n  function getValueSchema() internal pure returns (Schema) {\n    SchemaType[] memory _valueSchema = new SchemaType[](1);\n    _valueSchema[0] = SchemaType.BOOL;\n\n    return SchemaLib.encode(_valueSchema);\n  }\n\n  /** Get the table's key names */\n  function getKeyNames() internal pure returns (string[] memory keyNames) {\n    keyNames = new string[](1);\n    keyNames[0] = \"resourceId\";\n  }\n\n  /** Get the table's field names */\n  function getFieldNames() internal pure returns (string[] memory fieldNames) {\n    fieldNames = new string[](1);\n    fieldNames[0] = \"exists\";\n  }\n\n  /** Register the table with its config */\n  function register() internal {\n    StoreSwitch.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config */\n  function _register() internal {\n    StoreCore.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Register the table with its config (using the specified store) */\n  function register(IStore _store) internal {\n    _store.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n  }\n\n  /** Get exists */\n  function getExists(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /** Get exists */\n  function _getExists(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /** Get exists (using the specified store) */\n  function getExists(IStore _store, ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = _store.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /** Get exists */\n  function get(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /** Get exists */\n  function _get(ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /** Get exists (using the specified store) */\n  function get(IStore _store, ResourceId resourceId) internal view returns (bool exists) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    bytes32 _blob = _store.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);\n    return (_toBool(uint8(bytes1(_blob))));\n  }\n\n  /** Set exists */\n  function setExists(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /** Set exists */\n  function _setExists(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /** Set exists (using the specified store) */\n  function setExists(IStore _store, ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /** Set exists */\n  function set(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /** Set exists */\n  function _set(ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /** Set exists (using the specified store) */\n  function set(IStore _store, ResourceId resourceId, bool exists) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((exists)), _fieldLayout);\n  }\n\n  /** Delete all data for given keys */\n  function deleteRecord(ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreSwitch.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Delete all data for given keys */\n  function _deleteRecord(ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);\n  }\n\n  /** Delete all data for given keys (using the specified store) */\n  function deleteRecord(IStore _store, ResourceId resourceId) internal {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    _store.deleteRecord(_tableId, _keyTuple);\n  }\n\n  /** Tightly pack static data using this table's schema */\n  function encodeStatic(bool exists) internal pure returns (bytes memory) {\n    return abi.encodePacked(exists);\n  }\n\n  /** Tightly pack full data using this table's field layout */\n  function encode(bool exists) internal pure returns (bytes memory, PackedCounter, bytes memory) {\n    bytes memory _staticData = encodeStatic(exists);\n\n    PackedCounter _encodedLengths;\n    bytes memory _dynamicData;\n\n    return (_staticData, _encodedLengths, _dynamicData);\n  }\n\n  /** Encode keys as a bytes32 array using this table's field layout */\n  function encodeKeyTuple(ResourceId resourceId) internal pure returns (bytes32[] memory) {\n    bytes32[] memory _keyTuple = new bytes32[](1);\n    _keyTuple[0] = ResourceId.unwrap(resourceId);\n\n    return _keyTuple;\n  }\n}\n\nfunction _toBool(uint8 value) pure returns (bool result) {\n  assembly {\n    result := value\n  }\n}\n"
    },
    "src/CoreModule/IStoreEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\n\ninterface IStoreEvents {\n  event Store_SetRecord(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    bytes staticData,\n    PackedCounter encodedLengths,\n    bytes dynamicData\n  );\n  event Store_SpliceStaticData(ResourceId indexed tableId, bytes32[] keyTuple, uint48 start, bytes data);\n  event Store_SpliceDynamicData(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    uint48 start,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes data\n  );\n  event Store_DeleteRecord(ResourceId indexed tableId, bytes32[] keyTuple);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}