{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\nimport { Memory } from \"./Memory.sol\";\n\nlibrary Storage {\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, Memory.dataPointer(data), data.length);\n  }\n\n  /**\n   * Stores raw bytes to storage at the given storagePointer and offset (keeping the rest of the word intact)\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 memoryPointer, uint256 length) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, 8)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), mask),\n            // preserve the right part\n            and(sload(storagePointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * Load raw bytes from storage at the given storagePointer, offset, and length\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, length, offset, memoryPointer);\n    return result;\n  }\n\n  /**\n   * Append raw bytes from storage at the given storagePointer, offset, and length to the given memoryPointer\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(wordRemainder);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, 8), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the middle part\n              and(offsetData, mask),\n              // preserve the surrounding parts\n              and(mload(memoryPointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), mask),\n            // preserve the right part\n            and(mload(memoryPointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * Load up to 32 bytes from storage at the given storagePointer and offset.\n   * The return value is left-aligned, the bytes beyond the length are not zeroed out,\n   * and the caller is expected to truncate as needed.\n   * Since fields are tightly packed, they can span more than one slot.\n   * Since the they're max 32 bytes, they can span at most 2 slots.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, 8), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, 8), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}\n"
    },
    "src/CoreModule/leftMask.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/**\n * Adapted from https://github.com/dk1a/solidity-stringutils/blob/main/src/utils/mem.sol#L149-L167\n * @dev Left-aligned byte mask (e.g. for partial mload/mstore).\n * For byteLength >= 32 returns type(uint256).max\n *\n * length 0:   0x000000...000000\n * length 1:   0xff0000...000000\n * length 2:   0xffff00...000000\n * ...\n * length 30:  0xffffff...ff0000\n * length 31:  0xffffff...ffff00\n * length 32+: 0xffffff...ffffff\n */\nfunction leftMask(uint256 byteLength) pure returns (uint256) {\n  unchecked {\n    return ~(type(uint256).max >> (byteLength * 8));\n  }\n}\n"
    },
    "src/CoreModule/Memory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\n\nlibrary Memory {\n  /**\n   * In dynamic arrays the first word stores the length of data, after which comes the data.\n   * Example: 0x40 0x01 0x02\n   *          ^len ^data\n   */\n  function dataPointer(bytes memory data) internal pure returns (uint256 memoryPointer) {\n    assembly {\n      memoryPointer := add(data, 0x20)\n    }\n  }\n\n  function copy(uint256 fromPointer, uint256 toPointer, uint256 length) internal pure {\n    // Copy 32-byte chunks\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(toPointer, mload(fromPointer))\n      }\n      // Safe because total addition will be <= length (ptr+len is implicitly safe)\n      unchecked {\n        toPointer += 32;\n        fromPointer += 32;\n        length -= 32;\n      }\n    }\n    if (length == 0) return;\n\n    // Copy the 0-31 length tail\n    uint256 mask = leftMask(length);\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(\n        toPointer,\n        or(\n          // store the left part\n          and(mload(fromPointer), mask),\n          // preserve the right part\n          and(mload(toPointer), not(mask))\n        )\n      )\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}