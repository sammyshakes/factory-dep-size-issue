{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/IStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IStoreData } from \"./IStoreData.sol\";\nimport { IStoreRegistration } from \"./IStoreRegistration.sol\";\n\ninterface IStore is IStoreData, IStoreRegistration, IStoreErrors {}\n"
    },
    "src/CoreModule/IStoreErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { ResourceId } from \"./ResourceId.sol\";\n\ninterface IStoreErrors {\n  // Errors include a stringified version of the tableId for easier debugging if cleartext tableIds are used\n  error Store_TableAlreadyExists(ResourceId tableId, string tableIdString);\n  error Store_TableNotFound(ResourceId tableId, string tableIdString);\n  error Store_InvalidResourceType(bytes2 expected, ResourceId resourceId, string resourceIdString);\n\n  error Store_InvalidDynamicDataLength(uint256 expected, uint256 received);\n  error Store_IndexOutOfBounds(uint256 length, uint256 accessedIndex);\n  error Store_InvalidKeyNamesLength(uint256 expected, uint256 received);\n  error Store_InvalidFieldNamesLength(uint256 expected, uint256 received);\n  error Store_InvalidValueSchemaLength(uint256 expected, uint256 received);\n  error Store_InvalidSplice(uint40 startWithinField, uint40 deleteCount, uint40 fieldLength);\n}\n"
    },
    "src/CoreModule/IStoreData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IStoreRead } from \"./IStoreRead.sol\";\nimport { IStoreWrite } from \"./IStoreWrite.sol\";\n\n/**\n * The IStoreData interface includes methods for reading and writing table values.\n * These methods are frequently invoked during runtime, so it is essential to prioritize\n * optimizing their gas cost\n */\ninterface IStoreData is IStoreRead, IStoreWrite {\n  event HelloStore(bytes32 indexed storeVersion);\n\n  function storeVersion() external view returns (bytes32);\n}\n"
    },
    "src/CoreModule/IStoreRegistration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n/**\n * The IStoreRegistration interface includes methods for managing table field layouts,\n * metadata, and hooks, which are usually called once in the setup phase of an application,\n * making them less performance critical than the  methods.\n */\ninterface IStoreRegistration {\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] calldata keyNames,\n    string[] calldata fieldNames\n  ) external;\n\n  // Register hook to be called when a record or field is set or deleted\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) external;\n\n  // Unregister a hook for the given tableId\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) external;\n}\n"
    },
    "src/CoreModule/ResourceId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\ntype ResourceId is bytes32;\n\nuint256 constant TYPE_BITS = 2 * 8;\nuint256 constant NAME_BITS = 32 * 8 - TYPE_BITS;\n\nbytes32 constant TYPE_MASK = bytes32(hex\"ffff\");\n\nlibrary ResourceIdLib {\n  function encode(bytes2 typeId, bytes30 name) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(typeId) | (bytes32(name) >> TYPE_BITS));\n  }\n}\n\nlibrary ResourceIdInstance {\n  function getType(ResourceId resourceId) internal pure returns (bytes2) {\n    return bytes2(ResourceId.unwrap(resourceId));\n  }\n}\n"
    },
    "src/CoreModule/IStoreRead.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { Schema } from \"./Schema.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\ninterface IStoreRead {\n  function getFieldLayout(ResourceId tableId) external view returns (FieldLayout fieldLayout);\n\n  function getValueSchema(ResourceId tableId) external view returns (Schema valueSchema);\n\n  function getKeySchema(ResourceId tableId) external view returns (Schema keySchema);\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given tableId and key tuple, loading the field layout from storage\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple\n  ) external view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData);\n\n  /**\n   * Get full record (all fields, static and dynamic data) for the given tableId and key tuple, with the given field layout\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    FieldLayout fieldLayout\n  ) external view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData);\n\n  /**\n   * Get a single field from the given tableId and key tuple, loading the field layout from storage\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex\n  ) external view returns (bytes memory data);\n\n  /**\n   * Get a single field from the given tableId and key tuple, with the given field layout\n   */\n  function getField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (bytes memory data);\n\n  /**\n   * Get a single static field from the given tableId and key tuple, with the given value field layout.\n   * Note: the field value is left-aligned in the returned bytes32, the rest of the word is not zeroed out.\n   * Consumers are expected to truncate the returned value as needed.\n   */\n  function getStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (bytes32);\n\n  /**\n   * Get a single dynamic field from the given tableId and key tuple at the given dynamic field index.\n   * (Dynamic field index = field index - number of static fields)\n   */\n  function getDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) external view returns (bytes memory);\n\n  /**\n   * Get the byte length of a single field from the given tableId and key tuple, loading the field layout from storage\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex\n  ) external view returns (uint256);\n\n  /**\n   * Get the byte length of a single field from the given tableId and key tuple, with the given value field layout\n   */\n  function getFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    FieldLayout fieldLayout\n  ) external view returns (uint256);\n\n  /**\n   * Get the byte length of a single dynamic field from the given tableId and key tuple\n   */\n  function getDynamicFieldLength(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex\n  ) external view returns (uint256);\n\n  /**\n   * Get a byte slice (including start, excluding end) of a single dynamic field from the given tableId and key tuple, with the given value field layout.\n   * The slice is unchecked and will return invalid data if `start`:`end` overflow.\n   */\n  function getDynamicFieldSlice(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 start,\n    uint256 end\n  ) external view returns (bytes memory data);\n}\n"
    },
    "src/CoreModule/IStoreWrite.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IStoreEvents } from \"./IStoreEvents.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\ninterface IStoreWrite is IStoreEvents {\n  // Set full record (including full dynamic data)\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    bytes calldata staticData,\n    PackedCounter encodedLengths,\n    bytes calldata dynamicData\n  ) external;\n\n  // Splice data in the static part of the record\n  function spliceStaticData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint48 start,\n    bytes calldata data\n  ) external;\n\n  // Splice data in the dynamic part of the record\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes calldata data\n  ) external;\n\n  // Set partial data at field index\n  function setField(ResourceId tableId, bytes32[] calldata keyTuple, uint8 fieldIndex, bytes calldata data) external;\n\n  // Set partial data at field index\n  function setField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) external;\n\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) external;\n\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata data\n  ) external;\n\n  // Push encoded items to the dynamic field at field index\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata dataToPush\n  ) external;\n\n  // Pop byte length from the dynamic field at field index\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) external;\n\n  // Set full record (including full dynamic data)\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) external;\n}\n"
    },
    "src/CoreModule/FieldLayout.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { WORD_SIZE, WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants_1.sol\";\n\n// - 2 bytes for total length of all static fields\n// - 1 byte for number of static size fields\n// - 1 byte for number of dynamic size fields\n// - 28 bytes for 28 static field lengths\n// (MAX_DYNAMIC_FIELDS allows PackedCounter to pack the dynamic lengths into 1 word)\ntype FieldLayout is bytes32;\n\nusing FieldLayoutInstance for FieldLayout global;\n\n/**\n * Static functions for FieldLayout\n */\nlibrary FieldLayoutLib {\n  error FieldLayoutLib_InvalidLength(uint256 length);\n  error FieldLayoutLib_StaticLengthIsZero();\n  error FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n\n  /**\n   * Encode the given field layout into a single bytes32\n   */\n  function encode(uint256[] memory _staticFields, uint256 numDynamicFields) internal pure returns (FieldLayout) {\n    uint256 fieldLayout;\n    uint256 totalLength;\n    uint256 totalFields = _staticFields.length + numDynamicFields;\n    if (totalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib_InvalidLength(totalFields);\n    if (numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib_InvalidLength(numDynamicFields);\n\n    // Compute the total static length and store the field lengths in the encoded fieldLayout\n    for (uint256 i = 0; i < _staticFields.length; ) {\n      uint256 staticByteLength = _staticFields[i];\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n\n      unchecked {\n        // (safe because 28 (max _staticFields.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store lengths after the first 4 bytes (which are reserved for total length and field numbers)\n        // (safe because of the initial _staticFields.length check)\n        fieldLayout |= uint256(_staticFields[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    fieldLayout |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    fieldLayout |= _staticFields.length << LayoutOffsets.NUM_STATIC_FIELDS;\n    fieldLayout |= numDynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return FieldLayout.wrap(bytes32(fieldLayout));\n  }\n}\n\n/**\n * Instance functions for FieldLayout\n */\nlibrary FieldLayoutInstance {\n  /**\n   * Get the static byte length at the given index\n   */\n  function atIndex(FieldLayout fieldLayout, uint256 index) internal pure returns (uint256) {\n    unchecked {\n      return uint8(uint256(fieldLayout.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * BYTE_TO_BITS));\n    }\n  }\n\n  /**\n   * Get the total static byte length for the given field layout\n   */\n  function staticDataLength(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint256(FieldLayout.unwrap(fieldLayout)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * Get the number of static fields for the field layout\n   */\n  function numStaticFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * Get the number of dynamic length fields for the field layout\n   */\n  function numDynamicFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    return uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * Get the total number of fields for the field layout\n   */\n  function numFields(FieldLayout fieldLayout) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(fieldLayout.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * Check if the field layout is empty\n   */\n  function isEmpty(FieldLayout fieldLayout) internal pure returns (bool) {\n    return FieldLayout.unwrap(fieldLayout) == bytes32(0);\n  }\n\n  function validate(FieldLayout fieldLayout, bool allowEmpty) internal pure {\n    // FieldLayout must not be empty\n    if (!allowEmpty && fieldLayout.isEmpty()) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(0);\n\n    // FieldLayout must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = fieldLayout.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = fieldLayout.numStaticFields();\n    // FieldLayout must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert FieldLayoutLib.FieldLayoutLib_InvalidLength(_numTotalFields);\n\n    // Static lengths must be valid\n    for (uint256 i; i < _numStaticFields; ) {\n      uint256 staticByteLength = fieldLayout.atIndex(i);\n      if (staticByteLength == 0) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthIsZero();\n      } else if (staticByteLength > WORD_SIZE) {\n        revert FieldLayoutLib.FieldLayoutLib_StaticLengthDoesNotFitInAWord();\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * Unwrap the field layout\n   */\n  function unwrap(FieldLayout fieldLayout) internal pure returns (bytes32) {\n    return FieldLayout.unwrap(fieldLayout);\n  }\n}\n"
    },
    "src/CoreModule/Schema.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { SchemaType } from \"./SchemaType.sol\";\n\nimport { WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants_1.sol\";\n\n// - 2 bytes static length of the schema\n// - 1 byte for number of static size fields\n// - 1 byte for number of dynamic size fields\n// - 28 bytes for 28 schema types (MAX_DYNAMIC_FIELDS allows us to pack the lengths into 1 word)\ntype Schema is bytes32;\n\nusing SchemaInstance for Schema global;\n\n/**\n * Static functions for Schema\n */\nlibrary SchemaLib {\n  error SchemaLib_InvalidLength(uint256 length);\n  error SchemaLib_StaticTypeAfterDynamicType();\n\n  /**\n   * Encode the given schema into a single bytes32\n   */\n  function encode(SchemaType[] memory _schema) internal pure returns (Schema) {\n    if (_schema.length > MAX_TOTAL_FIELDS) revert SchemaLib_InvalidLength(_schema.length);\n    uint256 schema;\n    uint256 totalLength;\n    uint256 dynamicFields;\n\n    // Compute the length of the schema and the number of static fields\n    // and store the schema types in the encoded schema\n    for (uint256 i = 0; i < _schema.length; ) {\n      uint256 staticByteLength = _schema[i].getStaticByteLength();\n\n      if (staticByteLength == 0) {\n        // Increase the dynamic field count if the field is dynamic\n        // (safe because of the initial _schema.length check)\n        unchecked {\n          dynamicFields++;\n        }\n      } else if (dynamicFields > 0) {\n        // Revert if we have seen a dynamic field before, but now we see a static field\n        revert SchemaLib_StaticTypeAfterDynamicType();\n      }\n\n      unchecked {\n        // (safe because 28 (max _schema.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store schema types after the first 4 bytes (which are reserved for length and field numbers)\n        // (safe because of the initial _schema.length check)\n        schema |= uint256(_schema[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Require MAX_DYNAMIC_FIELDS\n    if (dynamicFields > MAX_DYNAMIC_FIELDS) revert SchemaLib_InvalidLength(dynamicFields);\n\n    // Get the static field count\n    uint256 staticFields;\n    unchecked {\n      staticFields = _schema.length - dynamicFields;\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    schema |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    schema |= staticFields << LayoutOffsets.NUM_STATIC_FIELDS;\n    schema |= dynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return Schema.wrap(bytes32(schema));\n  }\n}\n\n/**\n * Instance functions for Schema\n */\nlibrary SchemaInstance {\n  /**\n   * Get the length of the static data for the given schema\n   */\n  function staticDataLength(Schema schema) internal pure returns (uint256) {\n    return uint256(Schema.unwrap(schema)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * Get the type of the data for the given schema at the given index\n   */\n  function atIndex(Schema schema, uint256 index) internal pure returns (SchemaType) {\n    unchecked {\n      return SchemaType(uint8(uint256(schema.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * 8)));\n    }\n  }\n\n  /**\n   * Get the number of static fields for the given schema\n   */\n  function numStaticFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * Get the number of dynamic length fields for the given schema\n   */\n  function numDynamicFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * Get the total number of fields for the given schema\n   */\n  function numFields(Schema schema) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * Check if the given schema is empty\n   */\n  function isEmpty(Schema schema) internal pure returns (bool) {\n    return Schema.unwrap(schema) == bytes32(0);\n  }\n\n  function validate(Schema schema, bool allowEmpty) internal pure {\n    // Schema must not be empty\n    if (!allowEmpty && schema.isEmpty()) revert SchemaLib.SchemaLib_InvalidLength(0);\n\n    // Schema must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = schema.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert SchemaLib.SchemaLib_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = schema.numStaticFields();\n    // Schema must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert SchemaLib.SchemaLib_InvalidLength(_numTotalFields);\n\n    // No static field can be after a dynamic field\n    uint256 countStaticFields;\n    uint256 countDynamicFields;\n    for (uint256 i; i < _numTotalFields; ) {\n      if (schema.atIndex(i).getStaticByteLength() > 0) {\n        // Static field in dynamic part\n        if (i >= _numStaticFields) revert SchemaLib.SchemaLib_StaticTypeAfterDynamicType();\n        unchecked {\n          countStaticFields++;\n        }\n      } else {\n        // Dynamic field in static part\n        if (i < _numStaticFields) revert SchemaLib.SchemaLib_StaticTypeAfterDynamicType();\n        unchecked {\n          countDynamicFields++;\n        }\n      }\n      unchecked {\n        i++;\n      }\n    }\n\n    // Number of static fields must match\n    if (countStaticFields != _numStaticFields) revert SchemaLib.SchemaLib_InvalidLength(countStaticFields);\n\n    // Number of dynamic fields must match\n    if (countDynamicFields != _numDynamicFields) revert SchemaLib.SchemaLib_InvalidLength(countDynamicFields);\n  }\n\n  /**\n   * Unwrap the schema\n   */\n  function unwrap(Schema schema) internal pure returns (bytes32) {\n    return Schema.unwrap(schema);\n  }\n}\n"
    },
    "src/CoreModule/IStoreHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { IERC165, ERC165_INTERFACE_ID } from \"./IERC165_0.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n// ERC-165 Interface ID (see https://eips.ethereum.org/EIPS/eip-165)\nbytes4 constant STORE_HOOK_INTERFACE_ID = IStoreHook.onBeforeSetRecord.selector ^\n  IStoreHook.onAfterSetRecord.selector ^\n  IStoreHook.onBeforeSpliceStaticData.selector ^\n  IStoreHook.onAfterSpliceStaticData.selector ^\n  IStoreHook.onBeforeSpliceDynamicData.selector ^\n  IStoreHook.onAfterSpliceDynamicData.selector ^\n  IStoreHook.onBeforeDeleteRecord.selector ^\n  IStoreHook.onAfterDeleteRecord.selector ^\n  ERC165_INTERFACE_ID;\n\ninterface IStoreHook is IERC165 {\n  error StoreHook_NotImplemented();\n\n  function onBeforeSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  function onAfterSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  function onBeforeSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  function onAfterSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  function onBeforeSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  function onAfterSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  function onBeforeDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n\n  function onAfterDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n}\n"
    },
    "src/CoreModule/PackedCounter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n// - Last 7 bytes (uint56) are used for the total byte length of the dynamic data\n// - The next 5 byte (uint40) sections are used for the byte length of each field, indexed from right to left\ntype PackedCounter is bytes32;\n\nusing PackedCounterInstance for PackedCounter global;\n\n// Number of bits for the 7-byte accumulator\nuint256 constant ACC_BITS = 7 * 8;\n// Number of bits for the 5-byte sections\nuint256 constant VAL_BITS = 5 * 8;\n// Maximum value of a 5-byte section\nuint256 constant MAX_VAL = type(uint40).max;\n\n/**\n * Static functions for PackedCounter\n * The caller must ensure that the value arguments are <= MAX_VAL\n */\nlibrary PackedCounterLib {\n  function pack(uint256 a) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n\n  function pack(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e) internal pure returns (PackedCounter) {\n    uint256 packedCounter;\n    unchecked {\n      packedCounter = a + b + c + d + e;\n      packedCounter |= (uint256(a) << (ACC_BITS + VAL_BITS * 0));\n      packedCounter |= (uint256(b) << (ACC_BITS + VAL_BITS * 1));\n      packedCounter |= (uint256(c) << (ACC_BITS + VAL_BITS * 2));\n      packedCounter |= (uint256(d) << (ACC_BITS + VAL_BITS * 3));\n      packedCounter |= (uint256(e) << (ACC_BITS + VAL_BITS * 4));\n    }\n    return PackedCounter.wrap(bytes32(packedCounter));\n  }\n}\n\n/**\n * Instance functions for PackedCounter\n */\nlibrary PackedCounterInstance {\n  error PackedCounter_InvalidLength(uint256 length);\n\n  /**\n   * Decode the accumulated counter\n   * (right-most 7 bytes of packed counter)\n   */\n  function total(PackedCounter packedCounter) internal pure returns (uint256) {\n    return uint56(uint256(PackedCounter.unwrap(packedCounter)));\n  }\n\n  /**\n   * Decode the counter at the given index\n   * (right-to-left, 5 bytes per counter after the right-most 7 bytes)\n   */\n  function atIndex(PackedCounter packedCounter, uint8 index) internal pure returns (uint256) {\n    unchecked {\n      return uint40(uint256(PackedCounter.unwrap(packedCounter) >> (ACC_BITS + VAL_BITS * index)));\n    }\n  }\n\n  /**\n   * Set a counter at the given index, return the new packed counter\n   */\n  function setAtIndex(\n    PackedCounter packedCounter,\n    uint8 index,\n    uint256 newValueAtIndex\n  ) internal pure returns (PackedCounter) {\n    if (newValueAtIndex > MAX_VAL) {\n      revert PackedCounter_InvalidLength(newValueAtIndex);\n    }\n\n    uint256 rawPackedCounter = uint256(PackedCounter.unwrap(packedCounter));\n\n    // Get current lengths (total and at index)\n    uint256 accumulator = total(packedCounter);\n    uint256 currentValueAtIndex = atIndex(packedCounter, index);\n\n    // Compute the difference and update the total value\n    unchecked {\n      if (newValueAtIndex >= currentValueAtIndex) {\n        accumulator += newValueAtIndex - currentValueAtIndex;\n      } else {\n        accumulator -= currentValueAtIndex - newValueAtIndex;\n      }\n    }\n\n    // Set the new accumulated value and value at index\n    // (7 bytes total length, 5 bytes per dynamic field)\n    uint256 offset;\n    unchecked {\n      offset = ACC_BITS + VAL_BITS * index;\n    }\n    // Bitmask with 1s at the 5 bytes that form the value slot at the given index\n    uint256 mask = uint256(type(uint40).max) << offset;\n\n    // First set the last 7 bytes to 0, then set them to the new length\n    rawPackedCounter = (rawPackedCounter & ~uint256(type(uint56).max)) | accumulator;\n\n    // Zero out the value slot at the given index, then set the new value\n    rawPackedCounter = (rawPackedCounter & ~mask) | ((newValueAtIndex << offset) & mask);\n\n    return PackedCounter.wrap(bytes32(rawPackedCounter));\n  }\n\n  /*\n   * Unwrap the packed counter\n   */\n  function unwrap(PackedCounter packedCounter) internal pure returns (bytes32) {\n    return PackedCounter.unwrap(packedCounter);\n  }\n}\n"
    },
    "src/CoreModule/IStoreEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { ResourceId } from \"./ResourceId.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\n\ninterface IStoreEvents {\n  event Store_SetRecord(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    bytes staticData,\n    PackedCounter encodedLengths,\n    bytes dynamicData\n  );\n  event Store_SpliceStaticData(ResourceId indexed tableId, bytes32[] keyTuple, uint48 start, bytes data);\n  event Store_SpliceDynamicData(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    uint48 start,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes data\n  );\n  event Store_DeleteRecord(ResourceId indexed tableId, bytes32[] keyTuple);\n}\n"
    },
    "src/CoreModule/constants_1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Shared constants */\n\n// Total byte length of an EVM word\nuint256 constant WORD_SIZE = 32;\n// Index of the last byte in an EVM word\nuint256 constant WORD_LAST_INDEX = 31;\n// Conversion for bit shifting\nuint256 constant BYTE_TO_BITS = 8;\n\n// Schema's capacity\nuint256 constant MAX_TOTAL_FIELDS = 28;\n// FieldLayout's capacity\nuint256 constant MAX_STATIC_FIELDS = 28;\n// PackedCounter's capacity\nuint256 constant MAX_DYNAMIC_FIELDS = 5;\n\n// FieldLayout and Schema have the same offsets for metadata\nlibrary LayoutOffsets {\n  uint256 internal constant TOTAL_LENGTH = (WORD_SIZE - 2) * BYTE_TO_BITS;\n  uint256 internal constant NUM_STATIC_FIELDS = (WORD_SIZE - 2 - 1) * BYTE_TO_BITS;\n  uint256 internal constant NUM_DYNAMIC_FIELDS = (WORD_SIZE - 2 - 1 - 1) * BYTE_TO_BITS;\n}\n"
    },
    "src/CoreModule/SchemaType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nusing { getStaticByteLength } for SchemaType global;\n\n// WARNING: All enum changes MUST be mirrored for the other languages!\n// WARNING: SchemaType methods use hardcoded enum indexes, review them after any changes to the enum\n// TODO add and implement BYTES_ARRAY, STRING_ARRAY if they are needed (see https://github.com/latticexyz/mud/issues/447)\nenum SchemaType {\n  UINT8,\n  UINT16,\n  UINT24,\n  UINT32,\n  UINT40,\n  UINT48,\n  UINT56,\n  UINT64,\n  UINT72,\n  UINT80,\n  UINT88,\n  UINT96,\n  UINT104,\n  UINT112,\n  UINT120,\n  UINT128,\n  UINT136,\n  UINT144,\n  UINT152,\n  UINT160,\n  UINT168,\n  UINT176,\n  UINT184,\n  UINT192,\n  UINT200,\n  UINT208,\n  UINT216,\n  UINT224,\n  UINT232,\n  UINT240,\n  UINT248,\n  UINT256,\n  INT8,\n  INT16,\n  INT24,\n  INT32,\n  INT40,\n  INT48,\n  INT56,\n  INT64,\n  INT72,\n  INT80,\n  INT88,\n  INT96,\n  INT104,\n  INT112,\n  INT120,\n  INT128,\n  INT136,\n  INT144,\n  INT152,\n  INT160,\n  INT168,\n  INT176,\n  INT184,\n  INT192,\n  INT200,\n  INT208,\n  INT216,\n  INT224,\n  INT232,\n  INT240,\n  INT248,\n  INT256,\n  BYTES1,\n  BYTES2,\n  BYTES3,\n  BYTES4,\n  BYTES5,\n  BYTES6,\n  BYTES7,\n  BYTES8,\n  BYTES9,\n  BYTES10,\n  BYTES11,\n  BYTES12,\n  BYTES13,\n  BYTES14,\n  BYTES15,\n  BYTES16,\n  BYTES17,\n  BYTES18,\n  BYTES19,\n  BYTES20,\n  BYTES21,\n  BYTES22,\n  BYTES23,\n  BYTES24,\n  BYTES25,\n  BYTES26,\n  BYTES27,\n  BYTES28,\n  BYTES29,\n  BYTES30,\n  BYTES31,\n  BYTES32,\n  BOOL,\n  ADDRESS,\n  UINT8_ARRAY,\n  UINT16_ARRAY,\n  UINT24_ARRAY,\n  UINT32_ARRAY,\n  UINT40_ARRAY,\n  UINT48_ARRAY,\n  UINT56_ARRAY,\n  UINT64_ARRAY,\n  UINT72_ARRAY,\n  UINT80_ARRAY,\n  UINT88_ARRAY,\n  UINT96_ARRAY,\n  UINT104_ARRAY,\n  UINT112_ARRAY,\n  UINT120_ARRAY,\n  UINT128_ARRAY,\n  UINT136_ARRAY,\n  UINT144_ARRAY,\n  UINT152_ARRAY,\n  UINT160_ARRAY,\n  UINT168_ARRAY,\n  UINT176_ARRAY,\n  UINT184_ARRAY,\n  UINT192_ARRAY,\n  UINT200_ARRAY,\n  UINT208_ARRAY,\n  UINT216_ARRAY,\n  UINT224_ARRAY,\n  UINT232_ARRAY,\n  UINT240_ARRAY,\n  UINT248_ARRAY,\n  UINT256_ARRAY,\n  INT8_ARRAY,\n  INT16_ARRAY,\n  INT24_ARRAY,\n  INT32_ARRAY,\n  INT40_ARRAY,\n  INT48_ARRAY,\n  INT56_ARRAY,\n  INT64_ARRAY,\n  INT72_ARRAY,\n  INT80_ARRAY,\n  INT88_ARRAY,\n  INT96_ARRAY,\n  INT104_ARRAY,\n  INT112_ARRAY,\n  INT120_ARRAY,\n  INT128_ARRAY,\n  INT136_ARRAY,\n  INT144_ARRAY,\n  INT152_ARRAY,\n  INT160_ARRAY,\n  INT168_ARRAY,\n  INT176_ARRAY,\n  INT184_ARRAY,\n  INT192_ARRAY,\n  INT200_ARRAY,\n  INT208_ARRAY,\n  INT216_ARRAY,\n  INT224_ARRAY,\n  INT232_ARRAY,\n  INT240_ARRAY,\n  INT248_ARRAY,\n  INT256_ARRAY,\n  BYTES1_ARRAY,\n  BYTES2_ARRAY,\n  BYTES3_ARRAY,\n  BYTES4_ARRAY,\n  BYTES5_ARRAY,\n  BYTES6_ARRAY,\n  BYTES7_ARRAY,\n  BYTES8_ARRAY,\n  BYTES9_ARRAY,\n  BYTES10_ARRAY,\n  BYTES11_ARRAY,\n  BYTES12_ARRAY,\n  BYTES13_ARRAY,\n  BYTES14_ARRAY,\n  BYTES15_ARRAY,\n  BYTES16_ARRAY,\n  BYTES17_ARRAY,\n  BYTES18_ARRAY,\n  BYTES19_ARRAY,\n  BYTES20_ARRAY,\n  BYTES21_ARRAY,\n  BYTES22_ARRAY,\n  BYTES23_ARRAY,\n  BYTES24_ARRAY,\n  BYTES25_ARRAY,\n  BYTES26_ARRAY,\n  BYTES27_ARRAY,\n  BYTES28_ARRAY,\n  BYTES29_ARRAY,\n  BYTES30_ARRAY,\n  BYTES31_ARRAY,\n  BYTES32_ARRAY,\n  BOOL_ARRAY,\n  ADDRESS_ARRAY,\n  BYTES,\n  STRING\n}\n\n/**\n * Get the length of the data for the given schema type\n * (Because Solidity doesn't support constant arrays, we need to use a function)\n */\nfunction getStaticByteLength(SchemaType schemaType) pure returns (uint256) {\n  uint256 index = uint8(schemaType);\n\n  if (index < 97) {\n    // SchemaType enum elements are cyclically ordered for optimal static length lookup\n    // indexes: 00-31, 32-63, 64-95, 96, 97, ...\n    // lengths: 01-32, 01-32, 01-32, 01, 20, (the rest are 0s)\n    unchecked {\n      return (index & 31) + 1;\n    }\n  } else if (schemaType == SchemaType.ADDRESS) {\n    return 20;\n  } else {\n    // Return 0 for all dynamic types\n    return 0;\n  }\n}\n"
    },
    "src/CoreModule/IERC165_0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nbytes4 constant ERC165_INTERFACE_ID = IERC165.supportsInterface.selector;\n\n// See https://eips.ethereum.org/EIPS/eip-165\ninterface IERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}