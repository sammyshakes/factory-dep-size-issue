{
  "language": "Solidity",
  "sources": {
    "src/CoreModule/Schema.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { SchemaType } from \"./SchemaType.sol\";\n\nimport { WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS, LayoutOffsets } from \"./constants_1.sol\";\n\n// - 2 bytes static length of the schema\n// - 1 byte for number of static size fields\n// - 1 byte for number of dynamic size fields\n// - 28 bytes for 28 schema types (MAX_DYNAMIC_FIELDS allows us to pack the lengths into 1 word)\ntype Schema is bytes32;\n\nusing SchemaInstance for Schema global;\n\n/**\n * Static functions for Schema\n */\nlibrary SchemaLib {\n  error SchemaLib_InvalidLength(uint256 length);\n  error SchemaLib_StaticTypeAfterDynamicType();\n\n  /**\n   * Encode the given schema into a single bytes32\n   */\n  function encode(SchemaType[] memory _schema) internal pure returns (Schema) {\n    if (_schema.length > MAX_TOTAL_FIELDS) revert SchemaLib_InvalidLength(_schema.length);\n    uint256 schema;\n    uint256 totalLength;\n    uint256 dynamicFields;\n\n    // Compute the length of the schema and the number of static fields\n    // and store the schema types in the encoded schema\n    for (uint256 i = 0; i < _schema.length; ) {\n      uint256 staticByteLength = _schema[i].getStaticByteLength();\n\n      if (staticByteLength == 0) {\n        // Increase the dynamic field count if the field is dynamic\n        // (safe because of the initial _schema.length check)\n        unchecked {\n          dynamicFields++;\n        }\n      } else if (dynamicFields > 0) {\n        // Revert if we have seen a dynamic field before, but now we see a static field\n        revert SchemaLib_StaticTypeAfterDynamicType();\n      }\n\n      unchecked {\n        // (safe because 28 (max _schema.length) * 32 (max static length) < 2**16)\n        totalLength += staticByteLength;\n        // Sequentially store schema types after the first 4 bytes (which are reserved for length and field numbers)\n        // (safe because of the initial _schema.length check)\n        schema |= uint256(_schema[i]) << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n        i++;\n      }\n    }\n\n    // Require MAX_DYNAMIC_FIELDS\n    if (dynamicFields > MAX_DYNAMIC_FIELDS) revert SchemaLib_InvalidLength(dynamicFields);\n\n    // Get the static field count\n    uint256 staticFields;\n    unchecked {\n      staticFields = _schema.length - dynamicFields;\n    }\n\n    // Store total static length in the first 2 bytes,\n    // number of static fields in the 3rd byte,\n    // number of dynamic fields in the 4th byte\n    // (optimizer can handle this, no need for unchecked or single-line assignment)\n    schema |= totalLength << LayoutOffsets.TOTAL_LENGTH;\n    schema |= staticFields << LayoutOffsets.NUM_STATIC_FIELDS;\n    schema |= dynamicFields << LayoutOffsets.NUM_DYNAMIC_FIELDS;\n\n    return Schema.wrap(bytes32(schema));\n  }\n}\n\n/**\n * Instance functions for Schema\n */\nlibrary SchemaInstance {\n  /**\n   * Get the length of the static data for the given schema\n   */\n  function staticDataLength(Schema schema) internal pure returns (uint256) {\n    return uint256(Schema.unwrap(schema)) >> LayoutOffsets.TOTAL_LENGTH;\n  }\n\n  /**\n   * Get the type of the data for the given schema at the given index\n   */\n  function atIndex(Schema schema, uint256 index) internal pure returns (SchemaType) {\n    unchecked {\n      return SchemaType(uint8(uint256(schema.unwrap()) >> ((WORD_LAST_INDEX - 4 - index) * 8)));\n    }\n  }\n\n  /**\n   * Get the number of static fields for the given schema\n   */\n  function numStaticFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS);\n  }\n\n  /**\n   * Get the number of dynamic length fields for the given schema\n   */\n  function numDynamicFields(Schema schema) internal pure returns (uint256) {\n    return uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n  }\n\n  /**\n   * Get the total number of fields for the given schema\n   */\n  function numFields(Schema schema) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_STATIC_FIELDS) +\n        uint8(uint256(schema.unwrap()) >> LayoutOffsets.NUM_DYNAMIC_FIELDS);\n    }\n  }\n\n  /**\n   * Check if the given schema is empty\n   */\n  function isEmpty(Schema schema) internal pure returns (bool) {\n    return Schema.unwrap(schema) == bytes32(0);\n  }\n\n  function validate(Schema schema, bool allowEmpty) internal pure {\n    // Schema must not be empty\n    if (!allowEmpty && schema.isEmpty()) revert SchemaLib.SchemaLib_InvalidLength(0);\n\n    // Schema must have no more than MAX_DYNAMIC_FIELDS\n    uint256 _numDynamicFields = schema.numDynamicFields();\n    if (_numDynamicFields > MAX_DYNAMIC_FIELDS) revert SchemaLib.SchemaLib_InvalidLength(_numDynamicFields);\n\n    uint256 _numStaticFields = schema.numStaticFields();\n    // Schema must not have more than MAX_TOTAL_FIELDS in total\n    uint256 _numTotalFields = _numStaticFields + _numDynamicFields;\n    if (_numTotalFields > MAX_TOTAL_FIELDS) revert SchemaLib.SchemaLib_InvalidLength(_numTotalFields);\n\n    // No static field can be after a dynamic field\n    uint256 countStaticFields;\n    uint256 countDynamicFields;\n    for (uint256 i; i < _numTotalFields; ) {\n      if (schema.atIndex(i).getStaticByteLength() > 0) {\n        // Static field in dynamic part\n        if (i >= _numStaticFields) revert SchemaLib.SchemaLib_StaticTypeAfterDynamicType();\n        unchecked {\n          countStaticFields++;\n        }\n      } else {\n        // Dynamic field in static part\n        if (i < _numStaticFields) revert SchemaLib.SchemaLib_StaticTypeAfterDynamicType();\n        unchecked {\n          countDynamicFields++;\n        }\n      }\n      unchecked {\n        i++;\n      }\n    }\n\n    // Number of static fields must match\n    if (countStaticFields != _numStaticFields) revert SchemaLib.SchemaLib_InvalidLength(countStaticFields);\n\n    // Number of dynamic fields must match\n    if (countDynamicFields != _numDynamicFields) revert SchemaLib.SchemaLib_InvalidLength(countDynamicFields);\n  }\n\n  /**\n   * Unwrap the schema\n   */\n  function unwrap(Schema schema) internal pure returns (bytes32) {\n    return Schema.unwrap(schema);\n  }\n}\n"
    },
    "src/CoreModule/SchemaType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nusing { getStaticByteLength } for SchemaType global;\n\n// WARNING: All enum changes MUST be mirrored for the other languages!\n// WARNING: SchemaType methods use hardcoded enum indexes, review them after any changes to the enum\n// TODO add and implement BYTES_ARRAY, STRING_ARRAY if they are needed (see https://github.com/latticexyz/mud/issues/447)\nenum SchemaType {\n  UINT8,\n  UINT16,\n  UINT24,\n  UINT32,\n  UINT40,\n  UINT48,\n  UINT56,\n  UINT64,\n  UINT72,\n  UINT80,\n  UINT88,\n  UINT96,\n  UINT104,\n  UINT112,\n  UINT120,\n  UINT128,\n  UINT136,\n  UINT144,\n  UINT152,\n  UINT160,\n  UINT168,\n  UINT176,\n  UINT184,\n  UINT192,\n  UINT200,\n  UINT208,\n  UINT216,\n  UINT224,\n  UINT232,\n  UINT240,\n  UINT248,\n  UINT256,\n  INT8,\n  INT16,\n  INT24,\n  INT32,\n  INT40,\n  INT48,\n  INT56,\n  INT64,\n  INT72,\n  INT80,\n  INT88,\n  INT96,\n  INT104,\n  INT112,\n  INT120,\n  INT128,\n  INT136,\n  INT144,\n  INT152,\n  INT160,\n  INT168,\n  INT176,\n  INT184,\n  INT192,\n  INT200,\n  INT208,\n  INT216,\n  INT224,\n  INT232,\n  INT240,\n  INT248,\n  INT256,\n  BYTES1,\n  BYTES2,\n  BYTES3,\n  BYTES4,\n  BYTES5,\n  BYTES6,\n  BYTES7,\n  BYTES8,\n  BYTES9,\n  BYTES10,\n  BYTES11,\n  BYTES12,\n  BYTES13,\n  BYTES14,\n  BYTES15,\n  BYTES16,\n  BYTES17,\n  BYTES18,\n  BYTES19,\n  BYTES20,\n  BYTES21,\n  BYTES22,\n  BYTES23,\n  BYTES24,\n  BYTES25,\n  BYTES26,\n  BYTES27,\n  BYTES28,\n  BYTES29,\n  BYTES30,\n  BYTES31,\n  BYTES32,\n  BOOL,\n  ADDRESS,\n  UINT8_ARRAY,\n  UINT16_ARRAY,\n  UINT24_ARRAY,\n  UINT32_ARRAY,\n  UINT40_ARRAY,\n  UINT48_ARRAY,\n  UINT56_ARRAY,\n  UINT64_ARRAY,\n  UINT72_ARRAY,\n  UINT80_ARRAY,\n  UINT88_ARRAY,\n  UINT96_ARRAY,\n  UINT104_ARRAY,\n  UINT112_ARRAY,\n  UINT120_ARRAY,\n  UINT128_ARRAY,\n  UINT136_ARRAY,\n  UINT144_ARRAY,\n  UINT152_ARRAY,\n  UINT160_ARRAY,\n  UINT168_ARRAY,\n  UINT176_ARRAY,\n  UINT184_ARRAY,\n  UINT192_ARRAY,\n  UINT200_ARRAY,\n  UINT208_ARRAY,\n  UINT216_ARRAY,\n  UINT224_ARRAY,\n  UINT232_ARRAY,\n  UINT240_ARRAY,\n  UINT248_ARRAY,\n  UINT256_ARRAY,\n  INT8_ARRAY,\n  INT16_ARRAY,\n  INT24_ARRAY,\n  INT32_ARRAY,\n  INT40_ARRAY,\n  INT48_ARRAY,\n  INT56_ARRAY,\n  INT64_ARRAY,\n  INT72_ARRAY,\n  INT80_ARRAY,\n  INT88_ARRAY,\n  INT96_ARRAY,\n  INT104_ARRAY,\n  INT112_ARRAY,\n  INT120_ARRAY,\n  INT128_ARRAY,\n  INT136_ARRAY,\n  INT144_ARRAY,\n  INT152_ARRAY,\n  INT160_ARRAY,\n  INT168_ARRAY,\n  INT176_ARRAY,\n  INT184_ARRAY,\n  INT192_ARRAY,\n  INT200_ARRAY,\n  INT208_ARRAY,\n  INT216_ARRAY,\n  INT224_ARRAY,\n  INT232_ARRAY,\n  INT240_ARRAY,\n  INT248_ARRAY,\n  INT256_ARRAY,\n  BYTES1_ARRAY,\n  BYTES2_ARRAY,\n  BYTES3_ARRAY,\n  BYTES4_ARRAY,\n  BYTES5_ARRAY,\n  BYTES6_ARRAY,\n  BYTES7_ARRAY,\n  BYTES8_ARRAY,\n  BYTES9_ARRAY,\n  BYTES10_ARRAY,\n  BYTES11_ARRAY,\n  BYTES12_ARRAY,\n  BYTES13_ARRAY,\n  BYTES14_ARRAY,\n  BYTES15_ARRAY,\n  BYTES16_ARRAY,\n  BYTES17_ARRAY,\n  BYTES18_ARRAY,\n  BYTES19_ARRAY,\n  BYTES20_ARRAY,\n  BYTES21_ARRAY,\n  BYTES22_ARRAY,\n  BYTES23_ARRAY,\n  BYTES24_ARRAY,\n  BYTES25_ARRAY,\n  BYTES26_ARRAY,\n  BYTES27_ARRAY,\n  BYTES28_ARRAY,\n  BYTES29_ARRAY,\n  BYTES30_ARRAY,\n  BYTES31_ARRAY,\n  BYTES32_ARRAY,\n  BOOL_ARRAY,\n  ADDRESS_ARRAY,\n  BYTES,\n  STRING\n}\n\n/**\n * Get the length of the data for the given schema type\n * (Because Solidity doesn't support constant arrays, we need to use a function)\n */\nfunction getStaticByteLength(SchemaType schemaType) pure returns (uint256) {\n  uint256 index = uint8(schemaType);\n\n  if (index < 97) {\n    // SchemaType enum elements are cyclically ordered for optimal static length lookup\n    // indexes: 00-31, 32-63, 64-95, 96, 97, ...\n    // lengths: 01-32, 01-32, 01-32, 01, 20, (the rest are 0s)\n    unchecked {\n      return (index & 31) + 1;\n    }\n  } else if (schemaType == SchemaType.ADDRESS) {\n    return 20;\n  } else {\n    // Return 0 for all dynamic types\n    return 0;\n  }\n}\n"
    },
    "src/CoreModule/constants_1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Shared constants */\n\n// Total byte length of an EVM word\nuint256 constant WORD_SIZE = 32;\n// Index of the last byte in an EVM word\nuint256 constant WORD_LAST_INDEX = 31;\n// Conversion for bit shifting\nuint256 constant BYTE_TO_BITS = 8;\n\n// Schema's capacity\nuint256 constant MAX_TOTAL_FIELDS = 28;\n// FieldLayout's capacity\nuint256 constant MAX_STATIC_FIELDS = 28;\n// PackedCounter's capacity\nuint256 constant MAX_DYNAMIC_FIELDS = 5;\n\n// FieldLayout and Schema have the same offsets for metadata\nlibrary LayoutOffsets {\n  uint256 internal constant TOTAL_LENGTH = (WORD_SIZE - 2) * BYTE_TO_BITS;\n  uint256 internal constant NUM_STATIC_FIELDS = (WORD_SIZE - 2 - 1) * BYTE_TO_BITS;\n  uint256 internal constant NUM_DYNAMIC_FIELDS = (WORD_SIZE - 2 - 1 - 1) * BYTE_TO_BITS;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}